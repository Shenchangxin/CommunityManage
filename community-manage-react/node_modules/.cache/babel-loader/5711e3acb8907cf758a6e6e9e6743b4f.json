{"ast":null,"code":"'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(n => new RegExp(`(?:\\\\((?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\nnatives.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n\nclass StackUtils {\n  constructor(opts) {\n    opts = {\n      ignoredPackages: [],\n      ...opts\n    };\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd();\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  static nodeInternals() {\n    return [...natives];\n  }\n\n  clean(stack, indent = 0) {\n    indent = ' '.repeat(indent);\n\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n\n    if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n      stack = stack.slice(1);\n    }\n\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n\n      const isAtLine = /^\\s*at /.test(st);\n\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n\n      st = st.replace(`${this._cwd}/`, '');\n\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n    return result.map(line => `${indent}${line}\\n`).join('');\n  }\n\n  captureString(limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {\n      stackTraceLimit\n    } = Error;\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const {\n      stack\n    } = obj;\n    Error.stackTraceLimit = stackTraceLimit;\n    return this.clean(stack);\n  }\n\n  capture(limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {\n      prepareStackTrace,\n      stackTraceLimit\n    } = Error;\n\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n\n      return site;\n    };\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const {\n      stack\n    } = obj;\n    Object.assign(Error, {\n      prepareStackTrace,\n      stackTraceLimit\n    });\n    return stack;\n  }\n\n  at(fn = this.at) {\n    const [site] = this.capture(1, fn);\n\n    if (!site) {\n      return {};\n    }\n\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n    setFile(res, site.getFileName(), this._cwd);\n\n    if (site.isConstructor()) {\n      res.constructor = true;\n    }\n\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    } // Node v10 stopped with the isNative() on callsites, apparently\n\n    /* istanbul ignore next */\n\n\n    if (site.isNative()) {\n      res.native = true;\n    }\n\n    let typename;\n\n    try {\n      typename = site.getTypeName();\n    } catch (_) {}\n\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n\n    const fname = site.getFunctionName();\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    const meth = site.getMethodName();\n\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n\n    return res;\n  }\n\n  parseLine(line) {\n    const match = line && line.match(re);\n\n    if (!match) {\n      return null;\n    }\n\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n    const res = {};\n\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n\n    if (col) {\n      res.column = Number(col);\n    }\n\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += ` (${before}`;\n            break;\n          }\n        }\n      }\n    }\n\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n\n    setFile(res, file, this._cwd);\n\n    if (ctor) {\n      res.constructor = true;\n    }\n\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n\n    if (native) {\n      res.native = true;\n    }\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    if (method && fname !== method) {\n      res.method = method;\n    }\n\n    return res;\n  }\n\n}\n\nfunction setFile(result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n\n    if (filename.startsWith(`${cwd}/`)) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n  return new RegExp(`[\\/\\\\\\\\]node_modules[\\/\\\\\\\\](?:${packages.join('|')})[\\/\\\\\\\\][^:]+:\\\\d+:\\\\d+`);\n}\n\nconst re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' + // $1 = ctor if 'new'\n'(?:(new) )?' + // $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' + // (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' + // file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' + // maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\nmodule.exports = StackUtils;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/stack-utils/index.js"],"names":["escapeStringRegexp","require","natives","concat","builtinModules","map","n","RegExp","push","StackUtils","constructor","opts","ignoredPackages","internals","nodeInternals","cwd","process","_cwd","replace","_internals","ignoredPackagesRegExp","_wrapCallSite","wrapCallSite","clean","stack","indent","repeat","Array","isArray","split","test","slice","outdent","lastNonAtLine","result","forEach","st","some","internal","isAtLine","trimEnd","trim","line","join","captureString","limit","fn","Infinity","stackTraceLimit","Error","obj","captureStackTrace","capture","prepareStackTrace","site","Object","assign","at","res","getLineNumber","column","getColumnNumber","setFile","getFileName","isConstructor","isEval","evalOrigin","getEvalOrigin","isNative","native","typename","getTypeName","_","type","fname","getFunctionName","function","meth","getMethodName","method","parseLine","match","re","ctor","evalFile","evalLine","Number","evalCol","file","lnum","col","closeParen","closes","i","length","charAt","before","after","methodMatch","methodRe","evalColumn","filename","startsWith","packages","mod","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst natives = [].concat(\n  require('module').builtinModules,\n  'bootstrap_node',\n  'node',\n).map(n => new RegExp(`(?:\\\\((?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\n\nnatives.push(\n  /\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/,\n  /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/,\n  /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/\n);\n\nclass StackUtils {\n  constructor (opts) {\n    opts = {\n      ignoredPackages: [],\n      ...opts\n    };\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd()\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(\n      opts.internals,\n      ignoredPackagesRegExp(opts.ignoredPackages)\n    );\n\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  static nodeInternals () {\n    return [...natives];\n  }\n\n  clean (stack, indent = 0) {\n    indent = ' '.repeat(indent);\n\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n\n    if (!(/^\\s*at /.test(stack[0])) && (/^\\s*at /.test(stack[1]))) {\n      stack = stack.slice(1);\n    }\n\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n\n      const isAtLine = /^\\s*at /.test(st);\n\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n\n      st = st.replace(`${this._cwd}/`, '');\n\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n\n    return result.map(line => `${indent}${line}\\n`).join('');\n  }\n\n  captureString (limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {stackTraceLimit} = Error;\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n\n    Error.captureStackTrace(obj, fn);\n    const {stack} = obj;\n    Error.stackTraceLimit = stackTraceLimit;\n\n    return this.clean(stack);\n  }\n\n  capture (limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {prepareStackTrace, stackTraceLimit} = Error;\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n\n      return site;\n    };\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const { stack } = obj;\n    Object.assign(Error, {prepareStackTrace, stackTraceLimit});\n\n    return stack;\n  }\n\n  at (fn = this.at) {\n    const [site] = this.capture(1, fn);\n\n    if (!site) {\n      return {};\n    }\n\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n\n    setFile(res, site.getFileName(), this._cwd);\n\n    if (site.isConstructor()) {\n      res.constructor = true;\n    }\n\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    }\n\n    // Node v10 stopped with the isNative() on callsites, apparently\n    /* istanbul ignore next */\n    if (site.isNative()) {\n      res.native = true;\n    }\n\n    let typename;\n    try {\n      typename = site.getTypeName();\n    } catch (_) {\n    }\n\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n\n    const fname = site.getFunctionName();\n    if (fname) {\n      res.function = fname;\n    }\n\n    const meth = site.getMethodName();\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n\n    return res;\n  }\n\n  parseLine (line) {\n    const match = line && line.match(re);\n    if (!match) {\n      return null;\n    }\n\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n\n    const res = {};\n\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n\n    if (col) {\n      res.column = Number(col);\n    }\n\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += ` (${before}`;\n            break;\n          }\n        }\n      }\n    }\n\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n\n    setFile(res, file, this._cwd);\n\n    if (ctor) {\n      res.constructor = true;\n    }\n\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n\n    if (native) {\n      res.native = true;\n    }\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    if (method && fname !== method) {\n      res.method = method;\n    }\n\n    return res;\n  }\n}\n\nfunction setFile (result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n    if (filename.startsWith(`${cwd}/`)) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n\n  return new RegExp(`[\\/\\\\\\\\]node_modules[\\/\\\\\\\\](?:${packages.join('|')})[\\/\\\\\\\\][^:]+:\\\\d+:\\\\d+`)\n}\n\nconst re = new RegExp(\n  '^' +\n    // Sometimes we strip out the '    at' because it's noisy\n  '(?:\\\\s*at )?' +\n    // $1 = ctor if 'new'\n  '(?:(new) )?' +\n    // $2 = function name (can be literally anything)\n    // May contain method at the end as [as xyz]\n  '(?:(.*?) \\\\()?' +\n    // (eval at <anonymous> (file.js:1:1),\n    // $3 = eval origin\n    // $4:$5:$6 are eval file/line/col, but not normally reported\n  '(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n    // file:line:col\n    // $7:$8:$9\n    // $10 = 'native' if native\n  '(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n    // maybe close the paren, then end\n    // if $11 is ), then we only allow balanced parens in the filename\n    // any imbalance is placed on the fname.  This is a heuristic, and\n    // bound to be incorrect in some edge cases.  The bet is that\n    // having weird characters in method names is more common than\n    // having weird characters in filenames, which seems reasonable.\n  '(\\\\)?)$'\n);\n\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nmodule.exports = StackUtils;\n"]},"metadata":{},"sourceType":"script"}
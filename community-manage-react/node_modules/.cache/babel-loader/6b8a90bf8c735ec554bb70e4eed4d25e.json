{"ast":null,"code":"'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n\n  return false;\n};\n/**\n * Find a node of the given type\n */\n\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n/**\n * Find a node of the given type\n */\n\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return (Number(max) - Number(min)) / Number(step) >= limit;\n};\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n\n  if (node.commas >> 0 + node.ranges >> 0 === 0) {\n    node.invalid = true;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns true if a brace node is invalid.\n */\n\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n\n  if (block.commas >> 0 + block.ranges >> 0 === 0) {\n    block.invalid = true;\n    return true;\n  }\n\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns true if a node is an open or close node\n */\n\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n\n  return node.open === true || node.close === true;\n};\n/**\n * Reduce an array of text nodes.\n */\n\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n/**\n * Flatten an array\n */\n\n\nexports.flatten = (...args) => {\n  const result = [];\n\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n\n    return result;\n  };\n\n  flat(args);\n  return result;\n};","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/braces/lib/utils.js"],"names":["exports","isInteger","num","Number","trim","find","node","type","nodes","exceedsLimit","min","max","step","limit","escapeNode","block","n","escaped","value","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","push","flatten","args","result","flat","arr","i","length","ele","Array","isArray"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n"]},"metadata":{},"sourceType":"script"}
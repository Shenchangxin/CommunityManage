{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _replacePathSepForGlob = _interopRequireDefault(require('./replacePathSepForGlob'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst globsToMatchersMap = new Map();\nconst micromatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time micromatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling micromatch repeatedly with\n * the same globs, we can use this function which will build the micromatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      // Matchers that are negated have different behavior than matchers that\n      // are not negated, so we need to store this information ahead of time.\n      const {\n        negated\n      } = _micromatch().default.scan(glob, micromatchOptions);\n\n      const matcher = {\n        isMatch: _micromatch().default.matcher(glob, micromatchOptions),\n        negated\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n\n    return globsToMatchersMap.get(glob);\n  });\n  return path => {\n    const replacedPath = (0, _replacePathSepForGlob.default)(path);\n    let kept = undefined;\n    let negatives = 0;\n\n    for (let i = 0; i < matchers.length; i++) {\n      const {\n        isMatch,\n        negated\n      } = matchers[i];\n\n      if (negated) {\n        negatives++;\n      }\n\n      const matched = isMatch(replacedPath);\n\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/jest-util/build/globsToMatcher.js"],"names":["Object","defineProperty","exports","value","default","globsToMatcher","_micromatch","data","_interopRequireDefault","require","_replacePathSepForGlob","obj","__esModule","globsToMatchersMap","Map","micromatchOptions","dot","globs","length","matchers","map","glob","has","negated","scan","matcher","isMatch","set","get","path","replacedPath","kept","undefined","negatives","i","matched"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _replacePathSepForGlob = _interopRequireDefault(\n  require('./replacePathSepForGlob')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst globsToMatchersMap = new Map();\nconst micromatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time micromatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling micromatch repeatedly with\n * the same globs, we can use this function which will build the micromatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      // Matchers that are negated have different behavior than matchers that\n      // are not negated, so we need to store this information ahead of time.\n      const {negated} = _micromatch().default.scan(glob, micromatchOptions);\n\n      const matcher = {\n        isMatch: _micromatch().default.matcher(glob, micromatchOptions),\n        negated\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n\n    return globsToMatchersMap.get(glob);\n  });\n  return path => {\n    const replacedPath = (0, _replacePathSepForGlob.default)(path);\n    let kept = undefined;\n    let negatives = 0;\n\n    for (let i = 0; i < matchers.length; i++) {\n      const {isMatch, negated} = matchers[i];\n\n      if (negated) {\n        negatives++;\n      }\n\n      const matched = isMatch(replacedPath);\n\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}
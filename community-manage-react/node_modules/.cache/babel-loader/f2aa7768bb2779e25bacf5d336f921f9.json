{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.stringNotMatching = exports.stringMatching = exports.stringNotContaining = exports.stringContaining = exports.objectNotContaining = exports.objectContaining = exports.arrayNotContaining = exports.arrayContaining = exports.anything = exports.any = exports.AsymmetricMatcher = void 0;\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass AsymmetricMatcher {\n  constructor(sample) {\n    _defineProperty(this, 'sample', void 0);\n\n    _defineProperty(this, '$$typeof', void 0);\n\n    _defineProperty(this, 'inverse', void 0);\n\n    this.$$typeof = Symbol.for('jest.asymmetricMatcher');\n    this.sample = sample;\n  }\n\n}\n\nexports.AsymmetricMatcher = AsymmetricMatcher;\n\nclass Any extends AsymmetricMatcher {\n  constructor(sample) {\n    if (typeof sample === 'undefined') {\n      throw new TypeError('any() expects to be passed a constructor function. ' + 'Please pass one or use anything() to match any object.');\n    }\n\n    super(sample);\n  }\n\n  asymmetricMatch(other) {\n    if (this.sample == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.sample == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.sample == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.sample == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return typeof other == 'boolean';\n    }\n    /* global BigInt */\n\n\n    if (this.sample == BigInt) {\n      return typeof other == 'bigint';\n    }\n\n    if (this.sample == Symbol) {\n      return typeof other == 'symbol';\n    }\n\n    return other instanceof this.sample;\n  }\n\n  toString() {\n    return 'Any';\n  }\n\n  getExpectedType() {\n    if (this.sample == String) {\n      return 'string';\n    }\n\n    if (this.sample == Number) {\n      return 'number';\n    }\n\n    if (this.sample == Function) {\n      return 'function';\n    }\n\n    if (this.sample == Object) {\n      return 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return 'boolean';\n    }\n\n    return (0, _jasmineUtils.fnNameFor)(this.sample);\n  }\n\n  toAsymmetricMatcher() {\n    return 'Any<' + (0, _jasmineUtils.fnNameFor)(this.sample) + '>';\n  }\n\n}\n\nclass Anything extends AsymmetricMatcher {\n  asymmetricMatch(other) {\n    return !(0, _jasmineUtils.isUndefined)(other) && other !== null;\n  }\n\n  toString() {\n    return 'Anything';\n  } // No getExpectedType method, because it matches either null or undefined.\n\n\n  toAsymmetricMatcher() {\n    return 'Anything';\n  }\n\n}\n\nclass ArrayContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (!Array.isArray(this.sample)) {\n      throw new Error(`You must provide an array to ${this.toString()}, not '` + typeof this.sample + \"'.\");\n    }\n\n    const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every(item => other.some(another => (0, _jasmineUtils.equals)(item, another)));\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `Array${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'array';\n  }\n\n}\n\nclass ObjectContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (typeof this.sample !== 'object') {\n      throw new Error(`You must provide an object to ${this.toString()}, not '` + typeof this.sample + \"'.\");\n    }\n\n    if (this.inverse) {\n      for (const property in this.sample) {\n        if ((0, _jasmineUtils.hasProperty)(other, property) && (0, _jasmineUtils.equals)(this.sample[property], other[property]) && !(0, _utils.emptyObject)(this.sample[property]) && !(0, _utils.emptyObject)(other[property])) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      for (const property in this.sample) {\n        if (!(0, _jasmineUtils.hasProperty)(other, property) || !(0, _jasmineUtils.equals)(this.sample[property], other[property])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  toString() {\n    return `Object${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'object';\n  }\n\n}\n\nclass StringContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (!(0, _jasmineUtils.isA)('String', sample)) {\n      throw new Error('Expected is not a string');\n    }\n\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result = (0, _jasmineUtils.isA)('String', other) && other.includes(this.sample);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n\n}\n\nclass StringMatching extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (!(0, _jasmineUtils.isA)('String', sample) && !(0, _jasmineUtils.isA)('RegExp', sample)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    super(new RegExp(sample));\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result = (0, _jasmineUtils.isA)('String', other) && this.sample.test(other);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Matching`;\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n\n}\n\nconst any = expectedObject => new Any(expectedObject);\n\nexports.any = any;\n\nconst anything = () => new Anything();\n\nexports.anything = anything;\n\nconst arrayContaining = sample => new ArrayContaining(sample);\n\nexports.arrayContaining = arrayContaining;\n\nconst arrayNotContaining = sample => new ArrayContaining(sample, true);\n\nexports.arrayNotContaining = arrayNotContaining;\n\nconst objectContaining = sample => new ObjectContaining(sample);\n\nexports.objectContaining = objectContaining;\n\nconst objectNotContaining = sample => new ObjectContaining(sample, true);\n\nexports.objectNotContaining = objectNotContaining;\n\nconst stringContaining = expected => new StringContaining(expected);\n\nexports.stringContaining = stringContaining;\n\nconst stringNotContaining = expected => new StringContaining(expected, true);\n\nexports.stringNotContaining = stringNotContaining;\n\nconst stringMatching = expected => new StringMatching(expected);\n\nexports.stringMatching = stringMatching;\n\nconst stringNotMatching = expected => new StringMatching(expected, true);\n\nexports.stringNotMatching = stringNotMatching;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/expect/build/asymmetricMatchers.js"],"names":["Object","defineProperty","exports","value","stringNotMatching","stringMatching","stringNotContaining","stringContaining","objectNotContaining","objectContaining","arrayNotContaining","arrayContaining","anything","any","AsymmetricMatcher","_jasmineUtils","require","_utils","Symbol","global","_defineProperty","obj","key","enumerable","configurable","writable","constructor","sample","$$typeof","for","Any","TypeError","asymmetricMatch","other","String","Number","Function","Boolean","BigInt","toString","getExpectedType","fnNameFor","toAsymmetricMatcher","Anything","isUndefined","ArrayContaining","inverse","Array","isArray","Error","result","length","every","item","some","another","equals","ObjectContaining","property","hasProperty","emptyObject","StringContaining","isA","includes","StringMatching","RegExp","test","expectedObject","expected"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.stringNotMatching = exports.stringMatching = exports.stringNotContaining = exports.stringContaining = exports.objectNotContaining = exports.objectContaining = exports.arrayNotContaining = exports.arrayContaining = exports.anything = exports.any = exports.AsymmetricMatcher = void 0;\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nclass AsymmetricMatcher {\n  constructor(sample) {\n    _defineProperty(this, 'sample', void 0);\n\n    _defineProperty(this, '$$typeof', void 0);\n\n    _defineProperty(this, 'inverse', void 0);\n\n    this.$$typeof = Symbol.for('jest.asymmetricMatcher');\n    this.sample = sample;\n  }\n}\n\nexports.AsymmetricMatcher = AsymmetricMatcher;\n\nclass Any extends AsymmetricMatcher {\n  constructor(sample) {\n    if (typeof sample === 'undefined') {\n      throw new TypeError(\n        'any() expects to be passed a constructor function. ' +\n          'Please pass one or use anything() to match any object.'\n      );\n    }\n\n    super(sample);\n  }\n\n  asymmetricMatch(other) {\n    if (this.sample == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.sample == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.sample == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.sample == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return typeof other == 'boolean';\n    }\n    /* global BigInt */\n\n    if (this.sample == BigInt) {\n      return typeof other == 'bigint';\n    }\n\n    if (this.sample == Symbol) {\n      return typeof other == 'symbol';\n    }\n\n    return other instanceof this.sample;\n  }\n\n  toString() {\n    return 'Any';\n  }\n\n  getExpectedType() {\n    if (this.sample == String) {\n      return 'string';\n    }\n\n    if (this.sample == Number) {\n      return 'number';\n    }\n\n    if (this.sample == Function) {\n      return 'function';\n    }\n\n    if (this.sample == Object) {\n      return 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return 'boolean';\n    }\n\n    return (0, _jasmineUtils.fnNameFor)(this.sample);\n  }\n\n  toAsymmetricMatcher() {\n    return 'Any<' + (0, _jasmineUtils.fnNameFor)(this.sample) + '>';\n  }\n}\n\nclass Anything extends AsymmetricMatcher {\n  asymmetricMatch(other) {\n    return !(0, _jasmineUtils.isUndefined)(other) && other !== null;\n  }\n\n  toString() {\n    return 'Anything';\n  } // No getExpectedType method, because it matches either null or undefined.\n\n  toAsymmetricMatcher() {\n    return 'Anything';\n  }\n}\n\nclass ArrayContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (!Array.isArray(this.sample)) {\n      throw new Error(\n        `You must provide an array to ${this.toString()}, not '` +\n          typeof this.sample +\n          \"'.\"\n      );\n    }\n\n    const result =\n      this.sample.length === 0 ||\n      (Array.isArray(other) &&\n        this.sample.every(item =>\n          other.some(another => (0, _jasmineUtils.equals)(item, another))\n        ));\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `Array${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'array';\n  }\n}\n\nclass ObjectContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (typeof this.sample !== 'object') {\n      throw new Error(\n        `You must provide an object to ${this.toString()}, not '` +\n          typeof this.sample +\n          \"'.\"\n      );\n    }\n\n    if (this.inverse) {\n      for (const property in this.sample) {\n        if (\n          (0, _jasmineUtils.hasProperty)(other, property) &&\n          (0, _jasmineUtils.equals)(this.sample[property], other[property]) &&\n          !(0, _utils.emptyObject)(this.sample[property]) &&\n          !(0, _utils.emptyObject)(other[property])\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      for (const property in this.sample) {\n        if (\n          !(0, _jasmineUtils.hasProperty)(other, property) ||\n          !(0, _jasmineUtils.equals)(this.sample[property], other[property])\n        ) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  toString() {\n    return `Object${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'object';\n  }\n}\n\nclass StringContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (!(0, _jasmineUtils.isA)('String', sample)) {\n      throw new Error('Expected is not a string');\n    }\n\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result =\n      (0, _jasmineUtils.isA)('String', other) && other.includes(this.sample);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n}\n\nclass StringMatching extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (\n      !(0, _jasmineUtils.isA)('String', sample) &&\n      !(0, _jasmineUtils.isA)('RegExp', sample)\n    ) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    super(new RegExp(sample));\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result =\n      (0, _jasmineUtils.isA)('String', other) && this.sample.test(other);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Matching`;\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n}\n\nconst any = expectedObject => new Any(expectedObject);\n\nexports.any = any;\n\nconst anything = () => new Anything();\n\nexports.anything = anything;\n\nconst arrayContaining = sample => new ArrayContaining(sample);\n\nexports.arrayContaining = arrayContaining;\n\nconst arrayNotContaining = sample => new ArrayContaining(sample, true);\n\nexports.arrayNotContaining = arrayNotContaining;\n\nconst objectContaining = sample => new ObjectContaining(sample);\n\nexports.objectContaining = objectContaining;\n\nconst objectNotContaining = sample => new ObjectContaining(sample, true);\n\nexports.objectNotContaining = objectNotContaining;\n\nconst stringContaining = expected => new StringContaining(expected);\n\nexports.stringContaining = stringContaining;\n\nconst stringNotContaining = expected => new StringContaining(expected, true);\n\nexports.stringNotContaining = stringNotContaining;\n\nconst stringMatching = expected => new StringMatching(expected);\n\nexports.stringMatching = stringMatching;\n\nconst stringNotMatching = expected => new StringMatching(expected, true);\n\nexports.stringNotMatching = stringNotMatching;\n"]},"metadata":{},"sourceType":"script"}
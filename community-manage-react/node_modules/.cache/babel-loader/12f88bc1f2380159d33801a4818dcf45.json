{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.emptyObject = emptyObject;\nexports.isOneline = exports.isError = exports.partition = exports.sparseArrayEquality = exports.typeEquality = exports.subsetEquality = exports.iterableEquality = exports.getObjectSubset = exports.getPath = void 0;\n\nvar _jestGetType = require('jest-get-type');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\n\nconst hasPropertyInObject = (object, key) => {\n  const shouldTerminate = !object || typeof object !== 'object' || object === Object.prototype;\n\n  if (shouldTerminate) {\n    return false;\n  }\n\n  return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);\n};\n\nconst getPath = (object, propertyPath) => {\n  if (!Array.isArray(propertyPath)) {\n    propertyPath = propertyPath.split('.');\n  }\n\n  if (propertyPath.length) {\n    const lastProp = propertyPath.length === 1;\n    const prop = propertyPath[0];\n    const newObject = object[prop];\n\n    if (!lastProp && (newObject === null || newObject === undefined)) {\n      // This is not the last prop in the chain. If we keep recursing it will\n      // hit a `can't access property X of undefined | null`. At this point we\n      // know that the chain has broken and we can return right away.\n      return {\n        hasEndProp: false,\n        lastTraversedObject: object,\n        traversedPath: []\n      };\n    }\n\n    const result = getPath(newObject, propertyPath.slice(1));\n\n    if (result.lastTraversedObject === null) {\n      result.lastTraversedObject = object;\n    }\n\n    result.traversedPath.unshift(prop);\n\n    if (lastProp) {\n      // Does object have the property with an undefined value?\n      // Although primitive values support bracket notation (above)\n      // they would throw TypeError for in operator (below).\n      result.hasEndProp = newObject !== undefined || !(0, _jestGetType.isPrimitive)(object) && prop in object;\n\n      if (!result.hasEndProp) {\n        result.traversedPath.shift();\n      }\n    }\n\n    return result;\n  }\n\n  return {\n    lastTraversedObject: null,\n    traversedPath: [],\n    value: object\n  };\n}; // Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\nexports.getPath = getPath;\n\nconst getObjectSubset = (object, subset, seenReferences = new WeakMap()) => {\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  if (Array.isArray(object)) {\n    if (Array.isArray(subset) && subset.length === object.length) {\n      // The map method returns correct subclass of subset.\n      return subset.map((sub, i) => getObjectSubset(object[i], sub));\n    }\n  } else if (object instanceof Date) {\n    return object;\n  } else if (isObject(object) && isObject(subset)) {\n    if ((0, _jasmineUtils.equals)(object, subset, [iterableEquality, subsetEquality])) {\n      // Avoid unnecessary copy which might return Object instead of subclass.\n      return subset;\n    }\n\n    const trimmed = {};\n    seenReferences.set(object, trimmed);\n    Object.keys(object).filter(key => hasPropertyInObject(subset, key)).forEach(key => {\n      trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : getObjectSubset(object[key], subset[key], seenReferences);\n    });\n\n    if (Object.keys(trimmed).length > 0) {\n      return trimmed;\n    }\n  }\n\n  return object;\n};\n\nexports.getObjectSubset = getObjectSubset;\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = object => !!(object != null && object[IteratorSymbol]);\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\nconst iterableEquality = (a, b,\n/* eslint-enable @typescript-eslint/explicit-module-boundary-types */\naStack = [], bStack = []) => {\n  if (typeof a !== 'object' || typeof b !== 'object' || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b)) {\n    return undefined;\n  }\n\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  let length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n\n  const iterableEqualityWithStack = (a, b) => iterableEquality(a, b, [...aStack], [...bStack]);\n\n  if (a.size !== undefined) {\n    if (a.size !== b.size) {\n      return false;\n    } else if ((0, _jasmineUtils.isA)('Set', a) || (0, _jasmineUtils.isImmutableUnorderedSet)(a)) {\n      let allFound = true;\n\n      for (const aValue of a) {\n        if (!b.has(aValue)) {\n          let has = false;\n\n          for (const bValue of b) {\n            const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, [iterableEqualityWithStack]);\n\n            if (isEqual === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    } else if ((0, _jasmineUtils.isA)('Map', a) || (0, _jasmineUtils.isImmutableUnorderedKeyed)(a)) {\n      let allFound = true;\n\n      for (const aEntry of a) {\n        if (!b.has(aEntry[0]) || !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), [iterableEqualityWithStack])) {\n          let has = false;\n\n          for (const bEntry of b) {\n            const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], [iterableEqualityWithStack]);\n            let matchedValue = false;\n\n            if (matchedKey === true) {\n              matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], [iterableEqualityWithStack]);\n            }\n\n            if (matchedValue === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    }\n  }\n\n  const bIterator = b[IteratorSymbol]();\n\n  for (const aValue of a) {\n    const nextB = bIterator.next();\n\n    if (nextB.done || !(0, _jasmineUtils.equals)(aValue, nextB.value, [iterableEqualityWithStack])) {\n      return false;\n    }\n  }\n\n  if (!bIterator.next().done) {\n    return false;\n  } // Remove the first value from the stack of traversed values.\n\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n};\n\nexports.iterableEquality = iterableEquality;\n\nconst isObject = a => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = a => isObject(a) && !(a instanceof Error) && !(a instanceof Array) && !(a instanceof Date);\n\nconst subsetEquality = (object, subset) => {\n  // subsetEquality needs to keep track of the references\n  // it has already visited to avoid infinite loops in case\n  // there are circular references in the subset passed to it.\n  const subsetEqualityWithContext = (seenReferences = new WeakMap()) => (object, subset) => {\n    if (!isObjectWithKeys(subset)) {\n      return undefined;\n    }\n\n    return Object.keys(subset).every(key => {\n      if (isObjectWithKeys(subset[key])) {\n        if (seenReferences.has(subset[key])) {\n          return (0, _jasmineUtils.equals)(object[key], subset[key], [iterableEquality]);\n        }\n\n        seenReferences.set(subset[key], true);\n      }\n\n      const result = object != null && hasPropertyInObject(object, key) && (0, _jasmineUtils.equals)(object[key], subset[key], [iterableEquality, subsetEqualityWithContext(seenReferences)]); // The main goal of using seenReference is to avoid circular node on tree.\n      // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n      // We should keep the reference for a parent and its child only\n      // Thus we should delete the reference immediately so that it doesn't interfere\n      // other nodes within the same level on tree.\n\n      seenReferences.delete(subset[key]);\n      return result;\n    });\n  };\n\n  return subsetEqualityWithContext()(object, subset);\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\nexports.subsetEquality = subsetEquality;\n\nconst typeEquality = (a, b) => {\n  if (a == null || b == null || a.constructor === b.constructor) {\n    return undefined;\n  }\n\n  return false;\n};\n\nexports.typeEquality = typeEquality;\n\nconst sparseArrayEquality = (a, b) => {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return undefined;\n  } // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return (0, _jasmineUtils.equals)(a, b, [iterableEquality, typeEquality], true) && (0, _jasmineUtils.equals)(aKeys, bKeys);\n};\n\nexports.sparseArrayEquality = sparseArrayEquality;\n\nconst partition = (items, predicate) => {\n  const result = [[], []];\n  items.forEach(item => result[predicate(item) ? 0 : 1].push(item));\n  return result;\n}; // Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\n\n\nexports.partition = partition;\n\nconst isError = value => {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n      return true;\n\n    case '[object Exception]':\n      return true;\n\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n};\n\nexports.isError = isError;\n\nfunction emptyObject(obj) {\n  return obj && typeof obj === 'object' ? !Object.keys(obj).length : false;\n}\n\nconst MULTILINE_REGEXP = /[\\r\\n]/;\n\nconst isOneline = (expected, received) => typeof expected === 'string' && typeof received === 'string' && (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n\nexports.isOneline = isOneline;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/expect/build/utils.js"],"names":["Object","defineProperty","exports","value","emptyObject","isOneline","isError","partition","sparseArrayEquality","typeEquality","subsetEquality","iterableEquality","getObjectSubset","getPath","_jestGetType","require","_jasmineUtils","Symbol","global","hasPropertyInObject","object","key","shouldTerminate","prototype","hasOwnProperty","call","getPrototypeOf","propertyPath","Array","isArray","split","length","lastProp","prop","newObject","undefined","hasEndProp","lastTraversedObject","traversedPath","result","slice","unshift","isPrimitive","shift","subset","seenReferences","WeakMap","map","sub","i","Date","isObject","equals","trimmed","set","keys","filter","forEach","has","get","IteratorSymbol","iterator","hasIterator","a","b","aStack","bStack","constructor","push","iterableEqualityWithStack","size","isA","isImmutableUnorderedSet","allFound","aValue","bValue","isEqual","pop","isImmutableUnorderedKeyed","aEntry","bEntry","matchedKey","matchedValue","bIterator","nextB","next","done","isObjectWithKeys","Error","subsetEqualityWithContext","every","delete","aKeys","bKeys","items","predicate","item","toString","obj","MULTILINE_REGEXP","expected","received","test"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.emptyObject = emptyObject;\nexports.isOneline = exports.isError = exports.partition = exports.sparseArrayEquality = exports.typeEquality = exports.subsetEquality = exports.iterableEquality = exports.getObjectSubset = exports.getPath = void 0;\n\nvar _jestGetType = require('jest-get-type');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\nconst hasPropertyInObject = (object, key) => {\n  const shouldTerminate =\n    !object || typeof object !== 'object' || object === Object.prototype;\n\n  if (shouldTerminate) {\n    return false;\n  }\n\n  return (\n    Object.prototype.hasOwnProperty.call(object, key) ||\n    hasPropertyInObject(Object.getPrototypeOf(object), key)\n  );\n};\n\nconst getPath = (object, propertyPath) => {\n  if (!Array.isArray(propertyPath)) {\n    propertyPath = propertyPath.split('.');\n  }\n\n  if (propertyPath.length) {\n    const lastProp = propertyPath.length === 1;\n    const prop = propertyPath[0];\n    const newObject = object[prop];\n\n    if (!lastProp && (newObject === null || newObject === undefined)) {\n      // This is not the last prop in the chain. If we keep recursing it will\n      // hit a `can't access property X of undefined | null`. At this point we\n      // know that the chain has broken and we can return right away.\n      return {\n        hasEndProp: false,\n        lastTraversedObject: object,\n        traversedPath: []\n      };\n    }\n\n    const result = getPath(newObject, propertyPath.slice(1));\n\n    if (result.lastTraversedObject === null) {\n      result.lastTraversedObject = object;\n    }\n\n    result.traversedPath.unshift(prop);\n\n    if (lastProp) {\n      // Does object have the property with an undefined value?\n      // Although primitive values support bracket notation (above)\n      // they would throw TypeError for in operator (below).\n      result.hasEndProp =\n        newObject !== undefined ||\n        (!(0, _jestGetType.isPrimitive)(object) && prop in object);\n\n      if (!result.hasEndProp) {\n        result.traversedPath.shift();\n      }\n    }\n\n    return result;\n  }\n\n  return {\n    lastTraversedObject: null,\n    traversedPath: [],\n    value: object\n  };\n}; // Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nexports.getPath = getPath;\n\nconst getObjectSubset = (object, subset, seenReferences = new WeakMap()) => {\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  if (Array.isArray(object)) {\n    if (Array.isArray(subset) && subset.length === object.length) {\n      // The map method returns correct subclass of subset.\n      return subset.map((sub, i) => getObjectSubset(object[i], sub));\n    }\n  } else if (object instanceof Date) {\n    return object;\n  } else if (isObject(object) && isObject(subset)) {\n    if (\n      (0, _jasmineUtils.equals)(object, subset, [\n        iterableEquality,\n        subsetEquality\n      ])\n    ) {\n      // Avoid unnecessary copy which might return Object instead of subclass.\n      return subset;\n    }\n\n    const trimmed = {};\n    seenReferences.set(object, trimmed);\n    Object.keys(object)\n      .filter(key => hasPropertyInObject(subset, key))\n      .forEach(key => {\n        trimmed[key] = seenReferences.has(object[key])\n          ? seenReferences.get(object[key])\n          : getObjectSubset(object[key], subset[key], seenReferences);\n      });\n\n    if (Object.keys(trimmed).length > 0) {\n      return trimmed;\n    }\n  }\n\n  return object;\n};\n\nexports.getObjectSubset = getObjectSubset;\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = object => !!(object != null && object[IteratorSymbol]);\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nconst iterableEquality = (\n  a,\n  b,\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  aStack = [],\n  bStack = []\n) => {\n  if (\n    typeof a !== 'object' ||\n    typeof b !== 'object' ||\n    Array.isArray(a) ||\n    Array.isArray(b) ||\n    !hasIterator(a) ||\n    !hasIterator(b)\n  ) {\n    return undefined;\n  }\n\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  let length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n\n  const iterableEqualityWithStack = (a, b) =>\n    iterableEquality(a, b, [...aStack], [...bStack]);\n\n  if (a.size !== undefined) {\n    if (a.size !== b.size) {\n      return false;\n    } else if (\n      (0, _jasmineUtils.isA)('Set', a) ||\n      (0, _jasmineUtils.isImmutableUnorderedSet)(a)\n    ) {\n      let allFound = true;\n\n      for (const aValue of a) {\n        if (!b.has(aValue)) {\n          let has = false;\n\n          for (const bValue of b) {\n            const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, [\n              iterableEqualityWithStack\n            ]);\n\n            if (isEqual === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    } else if (\n      (0, _jasmineUtils.isA)('Map', a) ||\n      (0, _jasmineUtils.isImmutableUnorderedKeyed)(a)\n    ) {\n      let allFound = true;\n\n      for (const aEntry of a) {\n        if (\n          !b.has(aEntry[0]) ||\n          !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), [\n            iterableEqualityWithStack\n          ])\n        ) {\n          let has = false;\n\n          for (const bEntry of b) {\n            const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], [\n              iterableEqualityWithStack\n            ]);\n            let matchedValue = false;\n\n            if (matchedKey === true) {\n              matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], [\n                iterableEqualityWithStack\n              ]);\n            }\n\n            if (matchedValue === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    }\n  }\n\n  const bIterator = b[IteratorSymbol]();\n\n  for (const aValue of a) {\n    const nextB = bIterator.next();\n\n    if (\n      nextB.done ||\n      !(0, _jasmineUtils.equals)(aValue, nextB.value, [\n        iterableEqualityWithStack\n      ])\n    ) {\n      return false;\n    }\n  }\n\n  if (!bIterator.next().done) {\n    return false;\n  } // Remove the first value from the stack of traversed values.\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n};\n\nexports.iterableEquality = iterableEquality;\n\nconst isObject = a => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = a =>\n  isObject(a) &&\n  !(a instanceof Error) &&\n  !(a instanceof Array) &&\n  !(a instanceof Date);\n\nconst subsetEquality = (object, subset) => {\n  // subsetEquality needs to keep track of the references\n  // it has already visited to avoid infinite loops in case\n  // there are circular references in the subset passed to it.\n  const subsetEqualityWithContext = (seenReferences = new WeakMap()) => (\n    object,\n    subset\n  ) => {\n    if (!isObjectWithKeys(subset)) {\n      return undefined;\n    }\n\n    return Object.keys(subset).every(key => {\n      if (isObjectWithKeys(subset[key])) {\n        if (seenReferences.has(subset[key])) {\n          return (0, _jasmineUtils.equals)(object[key], subset[key], [\n            iterableEquality\n          ]);\n        }\n\n        seenReferences.set(subset[key], true);\n      }\n\n      const result =\n        object != null &&\n        hasPropertyInObject(object, key) &&\n        (0, _jasmineUtils.equals)(object[key], subset[key], [\n          iterableEquality,\n          subsetEqualityWithContext(seenReferences)\n        ]); // The main goal of using seenReference is to avoid circular node on tree.\n      // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n      // We should keep the reference for a parent and its child only\n      // Thus we should delete the reference immediately so that it doesn't interfere\n      // other nodes within the same level on tree.\n\n      seenReferences.delete(subset[key]);\n      return result;\n    });\n  };\n\n  return subsetEqualityWithContext()(object, subset);\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexports.subsetEquality = subsetEquality;\n\nconst typeEquality = (a, b) => {\n  if (a == null || b == null || a.constructor === b.constructor) {\n    return undefined;\n  }\n\n  return false;\n};\n\nexports.typeEquality = typeEquality;\n\nconst sparseArrayEquality = (a, b) => {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return undefined;\n  } // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return (\n    (0, _jasmineUtils.equals)(a, b, [iterableEquality, typeEquality], true) &&\n    (0, _jasmineUtils.equals)(aKeys, bKeys)\n  );\n};\n\nexports.sparseArrayEquality = sparseArrayEquality;\n\nconst partition = (items, predicate) => {\n  const result = [[], []];\n  items.forEach(item => result[predicate(item) ? 0 : 1].push(item));\n  return result;\n}; // Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\n\nexports.partition = partition;\n\nconst isError = value => {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n      return true;\n\n    case '[object Exception]':\n      return true;\n\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n};\n\nexports.isError = isError;\n\nfunction emptyObject(obj) {\n  return obj && typeof obj === 'object' ? !Object.keys(obj).length : false;\n}\n\nconst MULTILINE_REGEXP = /[\\r\\n]/;\n\nconst isOneline = (expected, received) =>\n  typeof expected === 'string' &&\n  typeof received === 'string' &&\n  (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n\nexports.isOneline = isOneline;\n"]},"metadata":{},"sourceType":"script"}
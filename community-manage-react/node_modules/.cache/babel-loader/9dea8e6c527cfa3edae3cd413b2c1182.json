{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _types = require('./types');\n\nvar _utils = require('./utils');\n\nvar _globalErrorHandlers = require('./globalErrorHandlers');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now; // TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\n\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result':\n      {\n        state.includeTestLocationInResult = true;\n        break;\n      }\n\n    case 'hook_start':\n      {\n        break;\n      }\n\n    case 'start_describe_definition':\n      {\n        const {\n          blockName,\n          mode\n        } = event;\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest\n        } = state;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        }\n\n        const describeBlock = (0, _utils.makeDescribe)(blockName, currentDescribeBlock, mode);\n        currentDescribeBlock.children.push(describeBlock);\n        state.currentDescribeBlock = describeBlock;\n        break;\n      }\n\n    case 'finish_describe_definition':\n      {\n        const {\n          currentDescribeBlock\n        } = state;\n        (0, _utils.invariant)(currentDescribeBlock, `currentDescribeBlock must be there`);\n\n        if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n          currentDescribeBlock.hooks.forEach(hook => {\n            hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n            state.unhandledErrors.push(hook.asyncError);\n          });\n        } // pass mode of currentDescribeBlock to tests\n        // but do not when there is already a single test with \"only\" mode\n\n\n        const shouldPassMode = !(currentDescribeBlock.mode === 'only' && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only'));\n\n        if (shouldPassMode) {\n          currentDescribeBlock.children.forEach(child => {\n            if (child.type === 'test' && !child.mode) {\n              child.mode = currentDescribeBlock.mode;\n            }\n          });\n        }\n\n        if (!state.hasFocusedTests && currentDescribeBlock.children.some(child => child.type === 'test' && child.mode === 'only')) {\n          state.hasFocusedTests = true;\n        }\n\n        if (currentDescribeBlock.parent) {\n          state.currentDescribeBlock = currentDescribeBlock.parent;\n        }\n\n        break;\n      }\n\n    case 'add_hook':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          hookType: type,\n          timeout\n        } = event;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a hook after tests have started running. Hooks must be defined synchronously.'));\n          break;\n        }\n\n        const parent = currentDescribeBlock;\n        currentDescribeBlock.hooks.push({\n          asyncError,\n          fn,\n          parent,\n          timeout,\n          type\n        });\n        break;\n      }\n\n    case 'add_test':\n      {\n        const {\n          currentDescribeBlock,\n          currentlyRunningTest,\n          hasStarted\n        } = state;\n        const {\n          asyncError,\n          fn,\n          mode,\n          testName: name,\n          timeout\n        } = event;\n\n        if (currentlyRunningTest) {\n          currentlyRunningTest.errors.push(new Error(`Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`));\n          break;\n        } else if (hasStarted) {\n          state.unhandledErrors.push(new Error('Cannot add a test after tests have started running. Tests must be defined synchronously.'));\n          break;\n        }\n\n        const test = (0, _utils.makeTest)(fn, mode, name, currentDescribeBlock, timeout, asyncError);\n\n        if (test.mode === 'only') {\n          state.hasFocusedTests = true;\n        }\n\n        currentDescribeBlock.children.push(test);\n        currentDescribeBlock.tests.push(test);\n        break;\n      }\n\n    case 'hook_failure':\n      {\n        const {\n          test,\n          describeBlock,\n          error,\n          hook\n        } = event;\n        const {\n          asyncError,\n          type\n        } = hook;\n\n        if (type === 'beforeAll') {\n          (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n          (0, _utils.addErrorToEachTestUnderDescribe)(describeBlock, error, asyncError);\n        } else if (type === 'afterAll') {\n          // Attaching `afterAll` errors to each test makes execution flow\n          // too complicated, so we'll consider them to be global.\n          state.unhandledErrors.push([error, asyncError]);\n        } else {\n          (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n          test.errors.push([error, asyncError]);\n        }\n\n        break;\n      }\n\n    case 'test_skip':\n      {\n        event.test.status = 'skip';\n        break;\n      }\n\n    case 'test_todo':\n      {\n        event.test.status = 'todo';\n        break;\n      }\n\n    case 'test_done':\n      {\n        event.test.duration = (0, _utils.getTestDuration)(event.test);\n        event.test.status = 'done';\n        state.currentlyRunningTest = null;\n        break;\n      }\n\n    case 'test_start':\n      {\n        state.currentlyRunningTest = event.test;\n        event.test.startedAt = jestNow();\n        event.test.invocations += 1;\n        break;\n      }\n\n    case 'test_fn_failure':\n      {\n        const {\n          error,\n          test: {\n            asyncError\n          }\n        } = event;\n        event.test.errors.push([error, asyncError]);\n        break;\n      }\n\n    case 'test_retry':\n      {\n        event.test.errors = [];\n        break;\n      }\n\n    case 'run_start':\n      {\n        state.hasStarted = true;\n        global[_types.TEST_TIMEOUT_SYMBOL] && (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n        break;\n      }\n\n    case 'run_finish':\n      {\n        break;\n      }\n\n    case 'setup':\n      {\n        // Uncaught exception handlers should be defined on the parent process\n        // object. If defined on the VM's process object they just no op and let\n        // the parent process crash. It might make sense to return a `dispatch`\n        // function to the parent process and register handlers there instead, but\n        // i'm not sure if this is works. For now i just replicated whatever\n        // jasmine was doing -- dabramov\n        state.parentProcess = event.parentProcess;\n        (0, _utils.invariant)(state.parentProcess);\n        state.originalGlobalErrorHandlers = (0, _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n\n        if (event.testNamePattern) {\n          state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n        }\n\n        break;\n      }\n\n    case 'teardown':\n      {\n        (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n        (0, _utils.invariant)(state.parentProcess);\n        (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(state.parentProcess, state.originalGlobalErrorHandlers);\n        break;\n      }\n\n    case 'error':\n      {\n        // It's very likely for long-running async tests to throw errors. In this\n        // case we want to catch them and fail the current test. At the same time\n        // there's a possibility that one test sets a long timeout, that will\n        // eventually throw after this test finishes but during some other test\n        // execution, which will result in one test's error failing another test.\n        // In any way, it should be possible to track where the error was thrown\n        // from.\n        state.currentlyRunningTest ? state.currentlyRunningTest.errors.push(event.error) : state.unhandledErrors.push(event.error);\n        break;\n      }\n  }\n};\n\nvar _default = eventHandler;\nexports.default = _default;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/jest-circus/build/eventHandler.js"],"names":["Object","defineProperty","exports","value","default","_types","require","_utils","_globalErrorHandlers","Symbol","global","jestNow","for","Date","now","eventHandler","event","state","name","includeTestLocationInResult","blockName","mode","currentDescribeBlock","currentlyRunningTest","errors","push","Error","describeBlock","makeDescribe","children","invariant","describeBlockHasTests","hooks","forEach","hook","asyncError","message","type","unhandledErrors","shouldPassMode","some","child","hasFocusedTests","parent","hasStarted","fn","hookType","timeout","testName","test","makeTest","tests","error","addErrorToEachTestUnderDescribe","status","duration","getTestDuration","startedAt","invocations","TEST_TIMEOUT_SYMBOL","testTimeout","parentProcess","originalGlobalErrorHandlers","injectGlobalErrorHandlers","testNamePattern","RegExp","restoreGlobalErrorHandlers","_default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _types = require('./types');\n\nvar _utils = require('./utils');\n\nvar _globalErrorHandlers = require('./globalErrorHandlers');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\n\n// TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error\nconst eventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result': {\n      state.includeTestLocationInResult = true;\n      break;\n    }\n\n    case 'hook_start': {\n      break;\n    }\n\n    case 'start_describe_definition': {\n      const {blockName, mode} = event;\n      const {currentDescribeBlock, currentlyRunningTest} = state;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      }\n\n      const describeBlock = (0, _utils.makeDescribe)(\n        blockName,\n        currentDescribeBlock,\n        mode\n      );\n      currentDescribeBlock.children.push(describeBlock);\n      state.currentDescribeBlock = describeBlock;\n      break;\n    }\n\n    case 'finish_describe_definition': {\n      const {currentDescribeBlock} = state;\n      (0, _utils.invariant)(\n        currentDescribeBlock,\n        `currentDescribeBlock must be there`\n      );\n\n      if (!(0, _utils.describeBlockHasTests)(currentDescribeBlock)) {\n        currentDescribeBlock.hooks.forEach(hook => {\n          hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n          state.unhandledErrors.push(hook.asyncError);\n        });\n      } // pass mode of currentDescribeBlock to tests\n      // but do not when there is already a single test with \"only\" mode\n\n      const shouldPassMode = !(\n        currentDescribeBlock.mode === 'only' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      );\n\n      if (shouldPassMode) {\n        currentDescribeBlock.children.forEach(child => {\n          if (child.type === 'test' && !child.mode) {\n            child.mode = currentDescribeBlock.mode;\n          }\n        });\n      }\n\n      if (\n        !state.hasFocusedTests &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only'\n        )\n      ) {\n        state.hasFocusedTests = true;\n      }\n\n      if (currentDescribeBlock.parent) {\n        state.currentDescribeBlock = currentDescribeBlock.parent;\n      }\n\n      break;\n    }\n\n    case 'add_hook': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, hookType: type, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a hook after tests have started running. Hooks must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const parent = currentDescribeBlock;\n      currentDescribeBlock.hooks.push({\n        asyncError,\n        fn,\n        parent,\n        timeout,\n        type\n      });\n      break;\n    }\n\n    case 'add_test': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, mode, testName: name, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`\n          )\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a test after tests have started running. Tests must be defined synchronously.'\n          )\n        );\n        break;\n      }\n\n      const test = (0, _utils.makeTest)(\n        fn,\n        mode,\n        name,\n        currentDescribeBlock,\n        timeout,\n        asyncError\n      );\n\n      if (test.mode === 'only') {\n        state.hasFocusedTests = true;\n      }\n\n      currentDescribeBlock.children.push(test);\n      currentDescribeBlock.tests.push(test);\n      break;\n    }\n\n    case 'hook_failure': {\n      const {test, describeBlock, error, hook} = event;\n      const {asyncError, type} = hook;\n\n      if (type === 'beforeAll') {\n        (0, _utils.invariant)(describeBlock, 'always present for `*All` hooks');\n        (0, _utils.addErrorToEachTestUnderDescribe)(\n          describeBlock,\n          error,\n          asyncError\n        );\n      } else if (type === 'afterAll') {\n        // Attaching `afterAll` errors to each test makes execution flow\n        // too complicated, so we'll consider them to be global.\n        state.unhandledErrors.push([error, asyncError]);\n      } else {\n        (0, _utils.invariant)(test, 'always present for `*Each` hooks');\n        test.errors.push([error, asyncError]);\n      }\n\n      break;\n    }\n\n    case 'test_skip': {\n      event.test.status = 'skip';\n      break;\n    }\n\n    case 'test_todo': {\n      event.test.status = 'todo';\n      break;\n    }\n\n    case 'test_done': {\n      event.test.duration = (0, _utils.getTestDuration)(event.test);\n      event.test.status = 'done';\n      state.currentlyRunningTest = null;\n      break;\n    }\n\n    case 'test_start': {\n      state.currentlyRunningTest = event.test;\n      event.test.startedAt = jestNow();\n      event.test.invocations += 1;\n      break;\n    }\n\n    case 'test_fn_failure': {\n      const {\n        error,\n        test: {asyncError}\n      } = event;\n      event.test.errors.push([error, asyncError]);\n      break;\n    }\n\n    case 'test_retry': {\n      event.test.errors = [];\n      break;\n    }\n\n    case 'run_start': {\n      state.hasStarted = true;\n      global[_types.TEST_TIMEOUT_SYMBOL] &&\n        (state.testTimeout = global[_types.TEST_TIMEOUT_SYMBOL]);\n      break;\n    }\n\n    case 'run_finish': {\n      break;\n    }\n\n    case 'setup': {\n      // Uncaught exception handlers should be defined on the parent process\n      // object. If defined on the VM's process object they just no op and let\n      // the parent process crash. It might make sense to return a `dispatch`\n      // function to the parent process and register handlers there instead, but\n      // i'm not sure if this is works. For now i just replicated whatever\n      // jasmine was doing -- dabramov\n      state.parentProcess = event.parentProcess;\n      (0, _utils.invariant)(state.parentProcess);\n      state.originalGlobalErrorHandlers = (0,\n      _globalErrorHandlers.injectGlobalErrorHandlers)(state.parentProcess);\n\n      if (event.testNamePattern) {\n        state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n      }\n\n      break;\n    }\n\n    case 'teardown': {\n      (0, _utils.invariant)(state.originalGlobalErrorHandlers);\n      (0, _utils.invariant)(state.parentProcess);\n      (0, _globalErrorHandlers.restoreGlobalErrorHandlers)(\n        state.parentProcess,\n        state.originalGlobalErrorHandlers\n      );\n      break;\n    }\n\n    case 'error': {\n      // It's very likely for long-running async tests to throw errors. In this\n      // case we want to catch them and fail the current test. At the same time\n      // there's a possibility that one test sets a long timeout, that will\n      // eventually throw after this test finishes but during some other test\n      // execution, which will result in one test's error failing another test.\n      // In any way, it should be possible to track where the error was thrown\n      // from.\n      state.currentlyRunningTest\n        ? state.currentlyRunningTest.errors.push(event.error)\n        : state.unhandledErrors.push(event.error);\n      break;\n    }\n  }\n};\n\nvar _default = eventHandler;\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.invariant = invariant;\nexports.parseSingleTestResult = exports.addErrorToEachTestUnderDescribe = exports.getTestID = exports.makeSingleTestResult = exports.makeRunResult = exports.getTestDuration = exports.callAsyncCircusFn = exports.describeBlockHasTests = exports.getEachHooksForTest = exports.getAllHooksForDescribe = exports.makeTest = exports.makeDescribe = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _jestUtil = require('jest-util');\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _dedent = _interopRequireDefault(require('dedent'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = _interopRequireDefault(require('pretty-format'));\n\nvar _state = require('./state');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nconst stackUtils = new _stackUtils.default({\n  cwd: 'A path that does not exist'\n});\nconst jestEachBuildDir = path.dirname(require.resolve('jest-each'));\n\nconst makeDescribe = (name, parent, mode) => {\n  let _mode = mode;\n\n  if (parent && !mode) {\n    // If not set explicitly, inherit from the parent describe.\n    _mode = parent.mode;\n  }\n\n  return {\n    type: 'describeBlock',\n    // eslint-disable-next-line sort-keys\n    children: [],\n    hooks: [],\n    mode: _mode,\n    name: (0, _jestUtil.convertDescriptorToString)(name),\n    parent,\n    tests: []\n  };\n};\n\nexports.makeDescribe = makeDescribe;\n\nconst makeTest = (fn, mode, name, parent, timeout, asyncError) => ({\n  type: 'test',\n  // eslint-disable-next-line sort-keys\n  asyncError,\n  duration: null,\n  errors: [],\n  fn,\n  invocations: 0,\n  mode,\n  name: (0, _jestUtil.convertDescriptorToString)(name),\n  parent,\n  startedAt: null,\n  status: null,\n  timeout\n}); // Traverse the tree of describe blocks and return true if at least one describe\n// block has an enabled test.\n\n\nexports.makeTest = makeTest;\n\nconst hasEnabledTest = describeBlock => {\n  const {\n    hasFocusedTests,\n    testNamePattern\n  } = (0, _state.getState)();\n  return describeBlock.children.some(child => child.type === 'describeBlock' ? hasEnabledTest(child) : !(child.mode === 'skip' || hasFocusedTests && child.mode !== 'only' || testNamePattern && !testNamePattern.test(getTestID(child))));\n};\n\nconst getAllHooksForDescribe = describe => {\n  const result = {\n    afterAll: [],\n    beforeAll: []\n  };\n\n  if (hasEnabledTest(describe)) {\n    for (const hook of describe.hooks) {\n      switch (hook.type) {\n        case 'beforeAll':\n          result.beforeAll.push(hook);\n          break;\n\n        case 'afterAll':\n          result.afterAll.push(hook);\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n\nexports.getAllHooksForDescribe = getAllHooksForDescribe;\n\nconst getEachHooksForTest = test => {\n  const result = {\n    afterEach: [],\n    beforeEach: []\n  };\n  let block = test.parent;\n\n  do {\n    const beforeEachForCurrentBlock = []; // TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released\n\n    let hook;\n\n    for (hook of block.hooks) {\n      switch (hook.type) {\n        case 'beforeEach':\n          beforeEachForCurrentBlock.push(hook);\n          break;\n\n        case 'afterEach':\n          result.afterEach.push(hook);\n          break;\n      }\n    } // 'beforeEach' hooks are executed from top to bottom, the opposite of the\n    // way we traversed it.\n\n\n    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];\n  } while (block = block.parent);\n\n  return result;\n};\n\nexports.getEachHooksForTest = getEachHooksForTest;\n\nconst describeBlockHasTests = describe => describe.children.some(child => child.type === 'test' || describeBlockHasTests(child));\n\nexports.describeBlockHasTests = describeBlockHasTests;\n\nconst _makeTimeoutMessage = (timeout, isHook) => `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${isHook ? 'hook' : 'test'}.\\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`; // Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\n\n\nconst {\n  setTimeout,\n  clearTimeout\n} = global;\n\nfunction checkIsError(error) {\n  return !!(error && error.message && error.stack);\n}\n\nconst callAsyncCircusFn = (testOrHook, testContext, {\n  isHook,\n  timeout\n}) => {\n  let timeoutID;\n  let completed = false;\n  const {\n    fn,\n    asyncError\n  } = testOrHook;\n  return new Promise((resolve, reject) => {\n    timeoutID = setTimeout(() => reject(_makeTimeoutMessage(timeout, isHook)), timeout); // If this fn accepts `done` callback we return a promise that fulfills as\n    // soon as `done` called.\n\n    if (fn.length) {\n      let returnedValue = undefined;\n\n      const done = reason => {\n        // We need to keep a stack here before the promise tick\n        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done); // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously\n\n        Promise.resolve().then(() => {\n          if (returnedValue !== undefined) {\n            asyncError.message = (0, _dedent.default)`\n      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n      Returned value: ${(0, _prettyFormat.default)(returnedValue, {\n              maxDepth: 3\n            })}\n      `;\n            return reject(asyncError);\n          }\n\n          let errorAsErrorObject;\n\n          if (checkIsError(reason)) {\n            errorAsErrorObject = reason;\n          } else {\n            errorAsErrorObject = errorAtDone;\n            errorAtDone.message = `Failed: ${(0, _prettyFormat.default)(reason, {\n              maxDepth: 3\n            })}`;\n          } // Consider always throwing, regardless if `reason` is set or not\n\n\n          if (completed && reason) {\n            errorAsErrorObject.message = 'Caught error after test environment was torn down\\n\\n' + errorAsErrorObject.message;\n            throw errorAsErrorObject;\n          }\n\n          return reason ? reject(errorAsErrorObject) : resolve();\n        });\n      };\n\n      returnedValue = fn.call(testContext, done);\n      return;\n    }\n\n    let returnedValue;\n\n    if ((0, _isGeneratorFn.default)(fn)) {\n      returnedValue = _co.default.wrap(fn).call({});\n    } else {\n      try {\n        returnedValue = fn.call(testContext);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    } // If it's a Promise, return it. Test for an object with a `then` function\n    // to support custom Promise implementations.\n\n\n    if (typeof returnedValue === 'object' && returnedValue !== null && typeof returnedValue.then === 'function') {\n      returnedValue.then(resolve, reject);\n      return;\n    }\n\n    if (!isHook && returnedValue !== undefined) {\n      reject(new Error((0, _dedent.default)`\n      test functions can only return Promise or undefined.\n      Returned value: ${(0, _prettyFormat.default)(returnedValue, {\n        maxDepth: 3\n      })}\n      `));\n      return;\n    } // Otherwise this test is synchronous, and if it didn't throw it means\n    // it passed.\n\n\n    resolve();\n  }).then(() => {\n    completed = true; // If timeout is not cleared/unrefed the node process won't exit until\n    // it's resolved.\n\n    timeoutID.unref && timeoutID.unref();\n    clearTimeout(timeoutID);\n  }).catch(error => {\n    completed = true;\n    timeoutID.unref && timeoutID.unref();\n    clearTimeout(timeoutID);\n    throw error;\n  });\n};\n\nexports.callAsyncCircusFn = callAsyncCircusFn;\n\nconst getTestDuration = test => {\n  const {\n    startedAt\n  } = test;\n  return typeof startedAt === 'number' ? jestNow() - startedAt : null;\n};\n\nexports.getTestDuration = getTestDuration;\n\nconst makeRunResult = (describeBlock, unhandledErrors) => ({\n  testResults: makeTestResults(describeBlock),\n  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack)\n});\n\nexports.makeRunResult = makeRunResult;\n\nconst makeSingleTestResult = test => {\n  const {\n    includeTestLocationInResult\n  } = (0, _state.getState)();\n  const testPath = [];\n  let parent = test;\n  const {\n    status\n  } = test;\n  invariant(status, 'Status should be present after tests are run.');\n\n  do {\n    testPath.unshift(parent.name);\n  } while (parent = parent.parent);\n\n  let location = null;\n\n  if (includeTestLocationInResult) {\n    var _parsedLine, _parsedLine$file;\n\n    const stackLines = test.asyncError.stack.split('\\n');\n    const stackLine = stackLines[1];\n    let parsedLine = stackUtils.parseLine(stackLine);\n\n    if ((_parsedLine = parsedLine) === null || _parsedLine === void 0 ? void 0 : (_parsedLine$file = _parsedLine.file) === null || _parsedLine$file === void 0 ? void 0 : _parsedLine$file.startsWith(jestEachBuildDir)) {\n      const stackLine = stackLines[4];\n      parsedLine = stackUtils.parseLine(stackLine);\n    }\n\n    if (parsedLine && typeof parsedLine.column === 'number' && typeof parsedLine.line === 'number') {\n      location = {\n        column: parsedLine.column,\n        line: parsedLine.line\n      };\n    }\n  }\n\n  const errorsDetailed = test.errors.map(_getError);\n  return {\n    duration: test.duration,\n    errors: errorsDetailed.map(getErrorStack),\n    errorsDetailed,\n    invocations: test.invocations,\n    location,\n    status,\n    testPath: Array.from(testPath)\n  };\n};\n\nexports.makeSingleTestResult = makeSingleTestResult;\n\nconst makeTestResults = describeBlock => {\n  const testResults = [];\n\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        {\n          testResults.push(...makeTestResults(child));\n          break;\n        }\n\n      case 'test':\n        {\n          testResults.push(makeSingleTestResult(child));\n          break;\n        }\n    }\n  }\n\n  return testResults;\n}; // Return a string that identifies the test (concat of parent describe block\n// names + test title)\n\n\nconst getTestID = test => {\n  const titles = [];\n  let parent = test;\n\n  do {\n    titles.unshift(parent.name);\n  } while (parent = parent.parent);\n\n  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME\n\n  return titles.join(' ');\n};\n\nexports.getTestID = getTestID;\n\nconst _getError = errors => {\n  let error;\n  let asyncError;\n\n  if (Array.isArray(errors)) {\n    error = errors[0];\n    asyncError = errors[1];\n  } else {\n    error = errors;\n    asyncError = new Error();\n  }\n\n  if (error && (error.stack || error.message)) {\n    return error;\n  }\n\n  asyncError.message = `thrown: ${(0, _prettyFormat.default)(error, {\n    maxDepth: 3\n  })}`;\n  return asyncError;\n};\n\nconst getErrorStack = error => error.stack || error.message;\n\nconst addErrorToEachTestUnderDescribe = (describeBlock, error, asyncError) => {\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        addErrorToEachTestUnderDescribe(child, error, asyncError);\n        break;\n\n      case 'test':\n        child.errors.push([error, asyncError]);\n        break;\n    }\n  }\n};\n\nexports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst parseSingleTestResult = testResult => {\n  let status;\n\n  if (testResult.status === 'skip') {\n    status = 'pending';\n  } else if (testResult.status === 'todo') {\n    status = 'todo';\n  } else if (testResult.errors.length > 0) {\n    status = 'failed';\n  } else {\n    status = 'passed';\n  }\n\n  const ancestorTitles = testResult.testPath.filter(name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME);\n  const title = ancestorTitles.pop();\n  return {\n    ancestorTitles,\n    duration: testResult.duration,\n    failureDetails: testResult.errorsDetailed,\n    failureMessages: Array.from(testResult.errors),\n    fullName: title ? ancestorTitles.concat(title).join(' ') : ancestorTitles.join(' '),\n    invocations: testResult.invocations,\n    location: testResult.location,\n    numPassingAsserts: 0,\n    status,\n    title: testResult.testPath[testResult.testPath.length - 1]\n  };\n};\n\nexports.parseSingleTestResult = parseSingleTestResult;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/jest-circus/build/utils.js"],"names":["Object","defineProperty","exports","value","invariant","parseSingleTestResult","addErrorToEachTestUnderDescribe","getTestID","makeSingleTestResult","makeRunResult","getTestDuration","callAsyncCircusFn","describeBlockHasTests","getEachHooksForTest","getAllHooksForDescribe","makeTest","makeDescribe","path","_interopRequireWildcard","require","_jestUtil","_isGeneratorFn","_interopRequireDefault","_co","_dedent","_stackUtils","_prettyFormat","_state","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","global","jestNow","for","Date","now","Promise","stackUtils","cwd","jestEachBuildDir","dirname","resolve","name","parent","mode","_mode","type","children","hooks","convertDescriptorToString","tests","fn","timeout","asyncError","duration","errors","invocations","startedAt","status","hasEnabledTest","describeBlock","hasFocusedTests","testNamePattern","getState","some","child","test","describe","result","afterAll","beforeAll","hook","push","afterEach","beforeEach","block","beforeEachForCurrentBlock","_makeTimeoutMessage","isHook","formatTime","setTimeout","clearTimeout","checkIsError","error","message","stack","testOrHook","testContext","timeoutID","completed","reject","length","returnedValue","undefined","done","reason","errorAtDone","ErrorWithStack","then","maxDepth","errorAsErrorObject","wrap","Error","unref","catch","unhandledErrors","testResults","makeTestResults","map","_getError","getErrorStack","includeTestLocationInResult","testPath","unshift","location","_parsedLine","_parsedLine$file","stackLines","split","stackLine","parsedLine","parseLine","file","startsWith","column","line","errorsDetailed","Array","from","titles","shift","join","isArray","condition","testResult","ancestorTitles","filter","ROOT_DESCRIBE_BLOCK_NAME","title","pop","failureDetails","failureMessages","fullName","concat","numPassingAsserts"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.invariant = invariant;\nexports.parseSingleTestResult = exports.addErrorToEachTestUnderDescribe = exports.getTestID = exports.makeSingleTestResult = exports.makeRunResult = exports.getTestDuration = exports.callAsyncCircusFn = exports.describeBlockHasTests = exports.getEachHooksForTest = exports.getAllHooksForDescribe = exports.makeTest = exports.makeDescribe = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _jestUtil = require('jest-util');\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _dedent = _interopRequireDefault(require('dedent'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = _interopRequireDefault(require('pretty-format'));\n\nvar _state = require('./state');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\nconst stackUtils = new _stackUtils.default({\n  cwd: 'A path that does not exist'\n});\nconst jestEachBuildDir = path.dirname(require.resolve('jest-each'));\n\nconst makeDescribe = (name, parent, mode) => {\n  let _mode = mode;\n\n  if (parent && !mode) {\n    // If not set explicitly, inherit from the parent describe.\n    _mode = parent.mode;\n  }\n\n  return {\n    type: 'describeBlock',\n    // eslint-disable-next-line sort-keys\n    children: [],\n    hooks: [],\n    mode: _mode,\n    name: (0, _jestUtil.convertDescriptorToString)(name),\n    parent,\n    tests: []\n  };\n};\n\nexports.makeDescribe = makeDescribe;\n\nconst makeTest = (fn, mode, name, parent, timeout, asyncError) => ({\n  type: 'test',\n  // eslint-disable-next-line sort-keys\n  asyncError,\n  duration: null,\n  errors: [],\n  fn,\n  invocations: 0,\n  mode,\n  name: (0, _jestUtil.convertDescriptorToString)(name),\n  parent,\n  startedAt: null,\n  status: null,\n  timeout\n}); // Traverse the tree of describe blocks and return true if at least one describe\n// block has an enabled test.\n\nexports.makeTest = makeTest;\n\nconst hasEnabledTest = describeBlock => {\n  const {hasFocusedTests, testNamePattern} = (0, _state.getState)();\n  return describeBlock.children.some(child =>\n    child.type === 'describeBlock'\n      ? hasEnabledTest(child)\n      : !(\n          child.mode === 'skip' ||\n          (hasFocusedTests && child.mode !== 'only') ||\n          (testNamePattern && !testNamePattern.test(getTestID(child)))\n        )\n  );\n};\n\nconst getAllHooksForDescribe = describe => {\n  const result = {\n    afterAll: [],\n    beforeAll: []\n  };\n\n  if (hasEnabledTest(describe)) {\n    for (const hook of describe.hooks) {\n      switch (hook.type) {\n        case 'beforeAll':\n          result.beforeAll.push(hook);\n          break;\n\n        case 'afterAll':\n          result.afterAll.push(hook);\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n\nexports.getAllHooksForDescribe = getAllHooksForDescribe;\n\nconst getEachHooksForTest = test => {\n  const result = {\n    afterEach: [],\n    beforeEach: []\n  };\n  let block = test.parent;\n\n  do {\n    const beforeEachForCurrentBlock = []; // TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released\n\n    let hook;\n\n    for (hook of block.hooks) {\n      switch (hook.type) {\n        case 'beforeEach':\n          beforeEachForCurrentBlock.push(hook);\n          break;\n\n        case 'afterEach':\n          result.afterEach.push(hook);\n          break;\n      }\n    } // 'beforeEach' hooks are executed from top to bottom, the opposite of the\n    // way we traversed it.\n\n    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];\n  } while ((block = block.parent));\n\n  return result;\n};\n\nexports.getEachHooksForTest = getEachHooksForTest;\n\nconst describeBlockHasTests = describe =>\n  describe.children.some(\n    child => child.type === 'test' || describeBlockHasTests(child)\n  );\n\nexports.describeBlockHasTests = describeBlockHasTests;\n\nconst _makeTimeoutMessage = (timeout, isHook) =>\n  `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${\n    isHook ? 'hook' : 'test'\n  }.\\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`; // Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\n\nconst {setTimeout, clearTimeout} = global;\n\nfunction checkIsError(error) {\n  return !!(error && error.message && error.stack);\n}\n\nconst callAsyncCircusFn = (testOrHook, testContext, {isHook, timeout}) => {\n  let timeoutID;\n  let completed = false;\n  const {fn, asyncError} = testOrHook;\n  return new Promise((resolve, reject) => {\n    timeoutID = setTimeout(\n      () => reject(_makeTimeoutMessage(timeout, isHook)),\n      timeout\n    ); // If this fn accepts `done` callback we return a promise that fulfills as\n    // soon as `done` called.\n\n    if (fn.length) {\n      let returnedValue = undefined;\n\n      const done = reason => {\n        // We need to keep a stack here before the promise tick\n        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done); // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously\n\n        Promise.resolve().then(() => {\n          if (returnedValue !== undefined) {\n            asyncError.message = (0, _dedent.default)`\n      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n      Returned value: ${(0, _prettyFormat.default)(returnedValue, {\n        maxDepth: 3\n      })}\n      `;\n            return reject(asyncError);\n          }\n\n          let errorAsErrorObject;\n\n          if (checkIsError(reason)) {\n            errorAsErrorObject = reason;\n          } else {\n            errorAsErrorObject = errorAtDone;\n            errorAtDone.message = `Failed: ${(0, _prettyFormat.default)(\n              reason,\n              {\n                maxDepth: 3\n              }\n            )}`;\n          } // Consider always throwing, regardless if `reason` is set or not\n\n          if (completed && reason) {\n            errorAsErrorObject.message =\n              'Caught error after test environment was torn down\\n\\n' +\n              errorAsErrorObject.message;\n            throw errorAsErrorObject;\n          }\n\n          return reason ? reject(errorAsErrorObject) : resolve();\n        });\n      };\n\n      returnedValue = fn.call(testContext, done);\n      return;\n    }\n\n    let returnedValue;\n\n    if ((0, _isGeneratorFn.default)(fn)) {\n      returnedValue = _co.default.wrap(fn).call({});\n    } else {\n      try {\n        returnedValue = fn.call(testContext);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    } // If it's a Promise, return it. Test for an object with a `then` function\n    // to support custom Promise implementations.\n\n    if (\n      typeof returnedValue === 'object' &&\n      returnedValue !== null &&\n      typeof returnedValue.then === 'function'\n    ) {\n      returnedValue.then(resolve, reject);\n      return;\n    }\n\n    if (!isHook && returnedValue !== undefined) {\n      reject(\n        new Error((0, _dedent.default)`\n      test functions can only return Promise or undefined.\n      Returned value: ${(0, _prettyFormat.default)(returnedValue, {\n        maxDepth: 3\n      })}\n      `)\n      );\n      return;\n    } // Otherwise this test is synchronous, and if it didn't throw it means\n    // it passed.\n\n    resolve();\n  })\n    .then(() => {\n      completed = true; // If timeout is not cleared/unrefed the node process won't exit until\n      // it's resolved.\n\n      timeoutID.unref && timeoutID.unref();\n      clearTimeout(timeoutID);\n    })\n    .catch(error => {\n      completed = true;\n      timeoutID.unref && timeoutID.unref();\n      clearTimeout(timeoutID);\n      throw error;\n    });\n};\n\nexports.callAsyncCircusFn = callAsyncCircusFn;\n\nconst getTestDuration = test => {\n  const {startedAt} = test;\n  return typeof startedAt === 'number' ? jestNow() - startedAt : null;\n};\n\nexports.getTestDuration = getTestDuration;\n\nconst makeRunResult = (describeBlock, unhandledErrors) => ({\n  testResults: makeTestResults(describeBlock),\n  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack)\n});\n\nexports.makeRunResult = makeRunResult;\n\nconst makeSingleTestResult = test => {\n  const {includeTestLocationInResult} = (0, _state.getState)();\n  const testPath = [];\n  let parent = test;\n  const {status} = test;\n  invariant(status, 'Status should be present after tests are run.');\n\n  do {\n    testPath.unshift(parent.name);\n  } while ((parent = parent.parent));\n\n  let location = null;\n\n  if (includeTestLocationInResult) {\n    var _parsedLine, _parsedLine$file;\n\n    const stackLines = test.asyncError.stack.split('\\n');\n    const stackLine = stackLines[1];\n    let parsedLine = stackUtils.parseLine(stackLine);\n\n    if (\n      (_parsedLine = parsedLine) === null || _parsedLine === void 0\n        ? void 0\n        : (_parsedLine$file = _parsedLine.file) === null ||\n          _parsedLine$file === void 0\n        ? void 0\n        : _parsedLine$file.startsWith(jestEachBuildDir)\n    ) {\n      const stackLine = stackLines[4];\n      parsedLine = stackUtils.parseLine(stackLine);\n    }\n\n    if (\n      parsedLine &&\n      typeof parsedLine.column === 'number' &&\n      typeof parsedLine.line === 'number'\n    ) {\n      location = {\n        column: parsedLine.column,\n        line: parsedLine.line\n      };\n    }\n  }\n\n  const errorsDetailed = test.errors.map(_getError);\n  return {\n    duration: test.duration,\n    errors: errorsDetailed.map(getErrorStack),\n    errorsDetailed,\n    invocations: test.invocations,\n    location,\n    status,\n    testPath: Array.from(testPath)\n  };\n};\n\nexports.makeSingleTestResult = makeSingleTestResult;\n\nconst makeTestResults = describeBlock => {\n  const testResults = [];\n\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock': {\n        testResults.push(...makeTestResults(child));\n        break;\n      }\n\n      case 'test': {\n        testResults.push(makeSingleTestResult(child));\n        break;\n      }\n    }\n  }\n\n  return testResults;\n}; // Return a string that identifies the test (concat of parent describe block\n// names + test title)\n\nconst getTestID = test => {\n  const titles = [];\n  let parent = test;\n\n  do {\n    titles.unshift(parent.name);\n  } while ((parent = parent.parent));\n\n  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME\n\n  return titles.join(' ');\n};\n\nexports.getTestID = getTestID;\n\nconst _getError = errors => {\n  let error;\n  let asyncError;\n\n  if (Array.isArray(errors)) {\n    error = errors[0];\n    asyncError = errors[1];\n  } else {\n    error = errors;\n    asyncError = new Error();\n  }\n\n  if (error && (error.stack || error.message)) {\n    return error;\n  }\n\n  asyncError.message = `thrown: ${(0, _prettyFormat.default)(error, {\n    maxDepth: 3\n  })}`;\n  return asyncError;\n};\n\nconst getErrorStack = error => error.stack || error.message;\n\nconst addErrorToEachTestUnderDescribe = (describeBlock, error, asyncError) => {\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        addErrorToEachTestUnderDescribe(child, error, asyncError);\n        break;\n\n      case 'test':\n        child.errors.push([error, asyncError]);\n        break;\n    }\n  }\n};\n\nexports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst parseSingleTestResult = testResult => {\n  let status;\n\n  if (testResult.status === 'skip') {\n    status = 'pending';\n  } else if (testResult.status === 'todo') {\n    status = 'todo';\n  } else if (testResult.errors.length > 0) {\n    status = 'failed';\n  } else {\n    status = 'passed';\n  }\n\n  const ancestorTitles = testResult.testPath.filter(\n    name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME\n  );\n  const title = ancestorTitles.pop();\n  return {\n    ancestorTitles,\n    duration: testResult.duration,\n    failureDetails: testResult.errorsDetailed,\n    failureMessages: Array.from(testResult.errors),\n    fullName: title\n      ? ancestorTitles.concat(title).join(' ')\n      : ancestorTitles.join(' '),\n    invocations: testResult.invocations,\n    location: testResult.location,\n    numPassingAsserts: 0,\n    status,\n    title: testResult.testPath[testResult.testPath.length - 1]\n  };\n};\n\nexports.parseSingleTestResult = parseSingleTestResult;\n"]},"metadata":{},"sourceType":"script"}
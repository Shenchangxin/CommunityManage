{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsRaw = exports.diffStringsUnified = exports.createPatchMark = exports.printDiffLines = exports.printAnnotation = exports.countChanges = exports.hasCommonDiff = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';\n\nconst printDeleteLine = (line, isFirstOrLast, {\n  aColor,\n  aIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = (line, isFirstOrLast, {\n  bColor,\n  bIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast, {\n  commonColor,\n  commonIndicator,\n  commonLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printCommonLine = printCommonLine;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\n\nexports.countChanges = countChanges;\n\nconst printAnnotation = ({\n  aAnnotation,\n  aColor,\n  aIndicator,\n  bAnnotation,\n  bColor,\n  bIndicator,\n  includeChangeCounts,\n  omitAnnotationLines\n}, changeCounts) => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.\n\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.\n\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest = aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;\n    bRest = bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;\n  }\n\n  return aColor(aIndicator + ' ' + aAnnotation + aRest) + '\\n' + bColor(bIndicator + ' ' + bAnnotation + bRest) + '\\n\\n';\n};\n\nexports.printAnnotation = printAnnotation;\n\nconst printDiffLines = (diffs, options) => printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options)); // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nexports.printDiffLines = printDiffLines;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {\n  patchColor\n}) => patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`); // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\n\nexports.createPatchMark = createPatchMark;\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(isMultiline ? a + '\\n' : a, isMultiline ? b + '\\n' : b, true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);\n      const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n\n  return (0, _diffLines.diffLinesUnified)(a.split('\\n'), b.split('\\n'), options);\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/jest-diff/build/printDiffs.js"],"names":["Object","defineProperty","exports","value","diffStringsRaw","diffStringsUnified","createPatchMark","printDiffLines","printAnnotation","countChanges","hasCommonDiff","printCommonLine","printInsertLine","printDeleteLine","_cleanupSemantic","require","_diffLines","_diffStrings","_interopRequireDefault","_getAlignedDiffs","_joinAlignedDiffs","_normalizeDiffOptions","obj","__esModule","default","formatTrailingSpaces","line","trailingSpaceFormatter","replace","match","printDiffLine","isFirstOrLast","color","indicator","emptyFirstOrLastLinePlaceholder","length","aColor","aIndicator","changeLineTrailingSpaceColor","bColor","bIndicator","commonColor","commonIndicator","commonLineTrailingSpaceColor","diffs","isMultiline","iLast","some","diff","i","DIFF_EQUAL","a","b","forEach","DIFF_DELETE","DIFF_INSERT","aAnnotation","bAnnotation","includeChangeCounts","omitAnnotationLines","changeCounts","aRest","bRest","aCount","String","bCount","baAnnotationLengthDiff","aAnnotationPadding","repeat","Math","max","bAnnotationPadding","baCountLengthDiff","aCountPadding","bCountPadding","options","expand","joinAlignedDiffsExpand","joinAlignedDiffsNoExpand","aStart","aEnd","bStart","bEnd","patchColor","includes","optionsNormalized","normalizeDiffOptions","lines","changeColor","diffLinesUnified","split","cleanup","cleanupSemantic"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsRaw = exports.diffStringsUnified = exports.createPatchMark = exports.printDiffLines = exports.printAnnotation = exports.countChanges = exports.hasCommonDiff = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) =>\n  line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n  line,\n  isFirstOrLast,\n  color,\n  indicator,\n  trailingSpaceFormatter,\n  emptyFirstOrLastLinePlaceholder\n) =>\n  line.length !== 0\n    ? color(\n        indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)\n      )\n    : indicator !== ' '\n    ? color(indicator)\n    : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n    ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder)\n    : '';\n\nconst printDeleteLine = (\n  line,\n  isFirstOrLast,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = (\n  line,\n  isFirstOrLast,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (\n  line,\n  isFirstOrLast,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nexports.printCommonLine = printCommonLine;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\n\nexports.countChanges = countChanges;\n\nconst printAnnotation = (\n  {\n    aAnnotation,\n    aColor,\n    aIndicator,\n    bAnnotation,\n    bColor,\n    bIndicator,\n    includeChangeCounts,\n    omitAnnotationLines\n  },\n  changeCounts\n) => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.\n\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.\n\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest =\n      aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;\n    bRest =\n      bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;\n  }\n\n  return (\n    aColor(aIndicator + ' ' + aAnnotation + aRest) +\n    '\\n' +\n    bColor(bIndicator + ' ' + bAnnotation + bRest) +\n    '\\n\\n'\n  );\n};\n\nexports.printAnnotation = printAnnotation;\n\nconst printDiffLines = (diffs, options) =>\n  printAnnotation(options, countChanges(diffs)) +\n  (options.expand\n    ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options)\n    : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options)); // In GNU diff format, indexes are one-based instead of zero-based.\n\nexports.printDiffLines = printDiffLines;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {patchColor}) =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\nexports.createPatchMark = createPatchMark;\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(\n      isMultiline ? a + '\\n' : a,\n      isMultiline ? b + '\\n' : b,\n      true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n        options\n      );\n      const lines = (0, _getAlignedDiffs.default)(\n        diffs,\n        optionsNormalized.changeColor\n      );\n      return printDiffLines(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n  return (0, _diffLines.diffLinesUnified)(\n    a.split('\\n'),\n    b.split('\\n'),\n    options\n  );\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;\n"]},"metadata":{},"sourceType":"script"}
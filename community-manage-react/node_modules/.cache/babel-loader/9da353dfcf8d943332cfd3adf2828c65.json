{"ast":null,"code":"\"use strict\";\n\nfunction dedent(strings) {\n  var raw = void 0;\n\n  if (typeof strings === \"string\") {\n    // dedent can be used as a plain function\n    raw = [strings];\n  } else {\n    raw = strings.raw;\n  } // first, perform interpolation\n\n\n  var result = \"\";\n\n  for (var i = 0; i < raw.length; i++) {\n    result += raw[i]. // join lines when there is a suppressed newline\n    replace(/\\\\\\n[ \\t]*/g, \"\"). // handle escaped backticks\n    replace(/\\\\`/g, \"`\");\n\n    if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {\n      result += arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    }\n  } // now strip indentation\n\n\n  var lines = result.split(\"\\n\");\n  var mindent = null;\n  lines.forEach(function (l) {\n    var m = l.match(/^(\\s+)\\S+/);\n\n    if (m) {\n      var indent = m[1].length;\n\n      if (!mindent) {\n        // this is the first indented line\n        mindent = indent;\n      } else {\n        mindent = Math.min(mindent, indent);\n      }\n    }\n  });\n\n  if (mindent !== null) {\n    result = lines.map(function (l) {\n      return l[0] === \" \" ? l.slice(mindent) : l;\n    }).join(\"\\n\");\n  } // dedent eats leading and trailing whitespace too\n\n\n  result = result.trim(); // handle escaped newlines at the end to ensure they don't get stripped too\n\n  return result.replace(/\\\\n/g, \"\\n\");\n}\n\nif (typeof module !== \"undefined\") {\n  module.exports = dedent;\n}","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/dedent/dist/dedent.js"],"names":["dedent","strings","raw","result","i","length","replace","arguments","undefined","lines","split","mindent","forEach","l","m","match","indent","Math","min","map","slice","join","trim","module","exports"],"mappings":"AAAA;;AAEA,SAASA,MAAT,CAAgBC,OAAhB,EAAyB;AAEvB,MAAIC,GAAG,GAAG,KAAK,CAAf;;AACA,MAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/B;AACAC,IAAAA,GAAG,GAAG,CAACD,OAAD,CAAN;AACD,GAHD,MAGO;AACLC,IAAAA,GAAG,GAAGD,OAAO,CAACC,GAAd;AACD,GARsB,CAUvB;;;AACA,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACG,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACnCD,IAAAA,MAAM,IAAID,GAAG,CAACE,CAAD,CAAH,EACV;AACAE,IAAAA,OAFU,CAEF,aAFE,EAEa,EAFb,GAIV;AACAA,IAAAA,OALU,CAKF,MALE,EAKM,GALN,CAAV;;AAOA,QAAIF,CAAC,IAAIG,SAAS,CAACF,MAAV,IAAoB,CAApB,GAAwB,CAAxB,GAA4BE,SAAS,CAACF,MAAV,GAAmB,CAAnD,CAAL,EAA4D;AAC1DF,MAAAA,MAAM,IAAII,SAAS,CAACF,MAAV,IAAoBD,CAAC,GAAG,CAAxB,GAA4BI,SAA5B,GAAwCD,SAAS,CAACH,CAAC,GAAG,CAAL,CAA3D;AACD;AACF,GAvBsB,CAyBvB;;;AACA,MAAIK,KAAK,GAAGN,MAAM,CAACO,KAAP,CAAa,IAAb,CAAZ;AACA,MAAIC,OAAO,GAAG,IAAd;AACAF,EAAAA,KAAK,CAACG,OAAN,CAAc,UAAUC,CAAV,EAAa;AACzB,QAAIC,CAAC,GAAGD,CAAC,CAACE,KAAF,CAAQ,WAAR,CAAR;;AACA,QAAID,CAAJ,EAAO;AACL,UAAIE,MAAM,GAAGF,CAAC,CAAC,CAAD,CAAD,CAAKT,MAAlB;;AACA,UAAI,CAACM,OAAL,EAAc;AACZ;AACAA,QAAAA,OAAO,GAAGK,MAAV;AACD,OAHD,MAGO;AACLL,QAAAA,OAAO,GAAGM,IAAI,CAACC,GAAL,CAASP,OAAT,EAAkBK,MAAlB,CAAV;AACD;AACF;AACF,GAXD;;AAaA,MAAIL,OAAO,KAAK,IAAhB,EAAsB;AACpBR,IAAAA,MAAM,GAAGM,KAAK,CAACU,GAAN,CAAU,UAAUN,CAAV,EAAa;AAC9B,aAAOA,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,GAAeA,CAAC,CAACO,KAAF,CAAQT,OAAR,CAAf,GAAkCE,CAAzC;AACD,KAFQ,EAENQ,IAFM,CAED,IAFC,CAAT;AAGD,GA7CsB,CA+CvB;;;AACAlB,EAAAA,MAAM,GAAGA,MAAM,CAACmB,IAAP,EAAT,CAhDuB,CAkDvB;;AACA,SAAOnB,MAAM,CAACG,OAAP,CAAe,MAAf,EAAuB,IAAvB,CAAP;AACD;;AAED,IAAI,OAAOiB,MAAP,KAAkB,WAAtB,EAAmC;AACjCA,EAAAA,MAAM,CAACC,OAAP,GAAiBxB,MAAjB;AACD","sourcesContent":["\"use strict\";\n\nfunction dedent(strings) {\n\n  var raw = void 0;\n  if (typeof strings === \"string\") {\n    // dedent can be used as a plain function\n    raw = [strings];\n  } else {\n    raw = strings.raw;\n  }\n\n  // first, perform interpolation\n  var result = \"\";\n  for (var i = 0; i < raw.length; i++) {\n    result += raw[i].\n    // join lines when there is a suppressed newline\n    replace(/\\\\\\n[ \\t]*/g, \"\").\n\n    // handle escaped backticks\n    replace(/\\\\`/g, \"`\");\n\n    if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {\n      result += arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    }\n  }\n\n  // now strip indentation\n  var lines = result.split(\"\\n\");\n  var mindent = null;\n  lines.forEach(function (l) {\n    var m = l.match(/^(\\s+)\\S+/);\n    if (m) {\n      var indent = m[1].length;\n      if (!mindent) {\n        // this is the first indented line\n        mindent = indent;\n      } else {\n        mindent = Math.min(mindent, indent);\n      }\n    }\n  });\n\n  if (mindent !== null) {\n    result = lines.map(function (l) {\n      return l[0] === \" \" ? l.slice(mindent) : l;\n    }).join(\"\\n\");\n  }\n\n  // dedent eats leading and trailing whitespace too\n  result = result.trim();\n\n  // handle escaped newlines at the end to ensure they don't get stripped too\n  return result.replace(/\\\\n/g, \"\\n\");\n}\n\nif (typeof module !== \"undefined\") {\n  module.exports = dedent;\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// The optional property of matcher context is true if undefined.\n\n\nconst isExpand = expand => expand !== false;\n\nconst PRINT_LIMIT = 3;\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = expected => expected.length === 0 ? NO_ARGUMENTS : expected.map(arg => (0, _jestMatcherUtils.printExpected)(arg)).join(', ');\n\nconst printReceivedArgs = (received, expected) => received.length === 0 ? NO_ARGUMENTS : received.map((arg, i) => Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg)).join(', ');\n\nconst printCommon = val => (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));\n\nconst isEqualValue = (expected, received) => (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);\n\nconst isEqualCall = (expected, received) => isEqualValue(expected, received);\n\nconst isEqualReturn = (expected, result) => result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = results => results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n\nconst printNumberOfReturns = (countReturns, countCalls) => `\\nNumber of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns)}` + (countCalls !== countReturns ? `\\nNumber of calls:   ${(0, _jestMatcherUtils.printReceived)(countCalls)}` : ''); // Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\n\n\nconst getRightAlignedPrinter = label => {\n  // Assume that the label contains a colon.\n  const index = label.indexOf(':');\n  const suffix = label.slice(index);\n  return (string, isExpectedCall) => (isExpectedCall ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length)) : ' '.repeat(Math.max(index - string.length))) + string + suffix;\n};\n\nconst printReceivedCallsNegative = (expected, indexedCalls, isOnlyCall, iExpectedCall) => {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  const label = 'Received:     ';\n\n  if (isOnlyCall) {\n    return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return 'Received\\n' + indexedCalls.reduce((printed, [i, args]) => printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected) + '\\n', '');\n};\n\nconst printExpectedReceivedCallsPositive = (expected, indexedCalls, expand, isOnlyCall, iExpectedCall) => {\n  const expectedLine = `Expected: ${printExpectedArgs(expected)}\\n`;\n\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  const label = 'Received: ';\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    const received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      const lines = [(0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'), (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'), ''];\n      const length = Math.max(expected.length, received.length);\n\n      for (let i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(`  ${printCommon(received[i])},`);\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            const difference = (0, _jestMatcherUtils.diff)(expected[i], received[i], {\n              expand\n            });\n\n            if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(difference.split('\\n').slice(3).join('\\n') + ',');\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push((0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (0, _jestMatcherUtils.stringify)(expected[i])) + ',');\n        }\n\n        if (i < received.length) {\n          lines.push((0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(received[i])) + ',');\n        }\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n\n    return expectedLine + label + printReceivedArgs(received, expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return expectedLine + 'Received\\n' + indexedCalls.reduce((printed, [i, received]) => {\n    const aligned = printAligned(String(i + 1), i === iExpectedCall);\n    return printed + ((i === iExpectedCall || iExpectedCall === undefined) && isLineDiffableCall(expected, received) ? aligned.replace(': ', '\\n') + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected)) + '\\n';\n  }, '');\n};\n\nconst indentation = 'Received'.replace(/\\w/g, ' ');\n\nconst printDiffCall = (expected, received, expand) => received.map((arg, i) => {\n  if (i < expected.length) {\n    if (isEqualValue(expected[i], arg)) {\n      return indentation + '  ' + printCommon(arg) + ',';\n    }\n\n    if (isLineDiffableArg(expected[i], arg)) {\n      const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {\n        expand\n      });\n\n      if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n        // Display diff with indentation.\n        // Omit annotation in case multiple args have diff.\n        return difference.split('\\n').slice(3).map(line => indentation + line).join('\\n') + ',';\n      }\n    }\n  } // Display + only if received arg has no corresponding expected arg.\n\n\n  return indentation + (i < expected.length ? '  ' + (0, _jestMatcherUtils.printReceived)(arg) : (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(arg))) + ',';\n}).join('\\n');\n\nconst isLineDiffableCall = (expected, received) => expected.some((arg, i) => i < received.length && isLineDiffableArg(arg, received[i])); // Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\n\n\nconst isLineDiffableArg = (expected, received) => {\n  const expectedType = (0, _jestGetType.default)(expected);\n  const receivedType = (0, _jestGetType.default)(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (_jestGetType.default.isPrimitive(expected)) {\n    return false;\n  }\n\n  if (expectedType === 'date' || expectedType === 'function' || expectedType === 'regexp') {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (expectedType === 'object' && typeof expected.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  if (receivedType === 'object' && typeof received.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  return true;\n};\n\nconst printResult = (result, expected) => result.type === 'throw' ? 'function call threw an error' : result.type === 'incomplete' ? 'function call has not returned yet' : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value); // Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\n\n\nconst printReceivedResults = (label, expected, indexedResults, isOnlyCall, iExpectedCall) => {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return label + printResult(indexedResults[0][1], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return label.replace(':', '').trim() + '\\n' + indexedResults.reduce((printed, [i, result]) => printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected) + '\\n', '');\n};\n\nconst createToBeCalledMatcher = matcherName => function (received, expected) {\n  const expectedArgument = '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const pass = count > 0;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(0)}\\n` + `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(count)}\\n\\n` + calls.reduce((lines, args, i) => {\n    if (lines.length < PRINT_LIMIT) {\n      lines.push(`${i + 1}: ${printReceivedArgs(args)}`);\n    }\n\n    return lines;\n  }, []).join('\\n') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of calls: >= ${(0, _jestMatcherUtils.printExpected)(1)}\\n` + `Received number of calls:    ${(0, _jestMatcherUtils.printReceived)(count)}`;\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnMatcher = matcherName => function (received, expected) {\n  const expectedArgument = '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n  const count = received.mock.results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n  const pass = count > 0;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(0)}\\n` + `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(count)}\\n\\n` + received.mock.results.reduce((lines, result, i) => {\n    if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n      lines.push(`${i + 1}: ${(0, _jestMatcherUtils.printReceived)(result.value)}`);\n    }\n\n    return lines;\n  }, []).join('\\n') + (received.mock.calls.length !== count ? `\\n\\nReceived number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of returns: >= ${(0, _jestMatcherUtils.printExpected)(1)}\\n` + `Received number of returns:    ${(0, _jestMatcherUtils.printReceived)(count)}` + (received.mock.calls.length !== count ? `\\nReceived number of calls:      ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : '');\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToBeCalledTimesMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n  const pass = count === expected;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + `\\n\\n` + `Expected number of calls: not ${(0, _jestMatcherUtils.printExpected)(expected)}` : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(count)}`;\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnTimesMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n  const count = received.mock.results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n  const pass = count === expected;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + `\\n\\n` + `Expected number of returns: not ${(0, _jestMatcherUtils.printExpected)(expected)}` + (received.mock.calls.length !== count ? `\\n\\nReceived number of calls:       ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(count)}` + (received.mock.calls.length !== count ? `\\nReceived number of calls:   ${(0, _jestMatcherUtils.printReceived)(received.mock.calls.length)}` : '');\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToBeCalledWithMatcher = matcherName => function (received, ...expected) {\n  const expectedArgument = '...expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const pass = calls.some(call => isEqualCall(expected, call));\n  const message = pass ? () => {\n    // Some examples of calls that are equal to expected value.\n    const indexedCalls = [];\n    let i = 0;\n\n    while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n      if (isEqualCall(expected, calls[i])) {\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: not ${printExpectedArgs(expected)}\\n` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1)) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  } : () => {\n    // Some examples of calls that are not equal to expected value.\n    const indexedCalls = [];\n    let i = 0;\n\n    while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n      indexedCalls.push([i, calls[i]]);\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnWithMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName();\n  const {\n    calls,\n    results\n  } = received.mock;\n  const pass = results.some(result => isEqualReturn(expected, result));\n  const message = pass ? () => {\n    // Some examples of results that are equal to expected value.\n    const indexedResults = [];\n    let i = 0;\n\n    while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n      if (isEqualReturn(expected, results[i])) {\n        indexedResults.push([i, results[i]]);\n      }\n\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    // Some examples of results that are not equal to expected value.\n    const indexedResults = [];\n    let i = 0;\n\n    while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n      indexedResults.push([i, results[i]]);\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + printReceivedResults('Received: ', expected, indexedResults, results.length === 1) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createLastCalledWithMatcher = matcherName => function (received, ...expected) {\n  const expectedArgument = '...expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const iLast = calls.length - 1;\n  const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n  const message = pass ? () => {\n    const indexedCalls = [];\n\n    if (iLast > 0) {\n      // Display preceding call as context.\n      indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n    }\n\n    indexedCalls.push([iLast, calls[iLast]]);\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: not ${printExpectedArgs(expected)}\\n` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iLast)) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  } : () => {\n    const indexedCalls = [];\n\n    if (iLast >= 0) {\n      if (iLast > 0) {\n        let i = iLast - 1; // Is there a preceding call that is equal to expected args?\n\n        while (i >= 0 && !isEqualCall(expected, calls[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iLast - 1; // otherwise, preceding call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      indexedCalls.push([iLast, calls[iLast]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iLast) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createLastReturnedMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName();\n  const {\n    calls,\n    results\n  } = received.mock;\n  const iLast = results.length - 1;\n  const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n  const message = pass ? () => {\n    const indexedResults = [];\n\n    if (iLast > 0) {\n      // Display preceding result as context.\n      indexedResults.push([iLast - 1, results[iLast - 1]]);\n    }\n\n    indexedResults.push([iLast, results[iLast]]);\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iLast)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    const indexedResults = [];\n\n    if (iLast >= 0) {\n      if (iLast > 0) {\n        let i = iLast - 1; // Is there a preceding result that is equal to expected value?\n\n        while (i >= 0 && !isEqualReturn(expected, results[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iLast - 1; // otherwise, preceding result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n\n      indexedResults.push([iLast, results[iLast]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iLast) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createNthCalledWithMatcher = matcherName => function (received, nth, ...expected) {\n  const expectedArgument = 'n';\n  const options = {\n    expectedColor: arg => arg,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: '...expected'\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n  if (!Number.isSafeInteger(nth) || nth < 1) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), `${expectedArgument} must be a positive integer`, (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n  }\n\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const length = calls.length;\n  const iNth = nth - 1;\n  const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n  const message = pass ? () => {\n    // Display preceding and following calls,\n    // in case assertions fails because index is off by one.\n    const indexedCalls = [];\n\n    if (iNth - 1 >= 0) {\n      indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n    }\n\n    indexedCalls.push([iNth, calls[iNth]]);\n\n    if (iNth + 1 < length) {\n      indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `n: ${nth}\\n` + `Expected: not ${printExpectedArgs(expected)}\\n` + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iNth)) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  } : () => {\n    // Display preceding and following calls:\n    // * nearest call that is equal to expected args\n    // * otherwise, adjacent call\n    // in case assertions fails because of index, especially off by one.\n    const indexedCalls = [];\n\n    if (iNth < length) {\n      if (iNth - 1 >= 0) {\n        let i = iNth - 1; // Is there a preceding call that is equal to expected args?\n\n        while (i >= 0 && !isEqualCall(expected, calls[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iNth - 1; // otherwise, adjacent call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      indexedCalls.push([iNth, calls[iNth]]);\n\n      if (iNth + 1 < length) {\n        let i = iNth + 1; // Is there a following call that is equal to expected args?\n\n        while (i < length && !isEqualCall(expected, calls[i])) {\n          i += 1;\n        }\n\n        if (i >= length) {\n          i = iNth + 1; // otherwise, adjacent call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n    } else if (length > 0) {\n      // The number of received calls is fewer than the expected number.\n      let i = length - 1; // Is there a call that is equal to expected args?\n\n      while (i >= 0 && !isEqualCall(expected, calls[i])) {\n        i -= 1;\n      }\n\n      if (i < 0) {\n        i = length - 1; // otherwise, last call\n      }\n\n      indexedCalls.push([i, calls[i]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `n: ${nth}\\n` + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iNth) + `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(calls.length)}`;\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createNthReturnedWithMatcher = matcherName => function (received, nth, expected) {\n  const expectedArgument = 'n';\n  const options = {\n    expectedColor: arg => arg,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: 'expected'\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n\n  if (!Number.isSafeInteger(nth) || nth < 1) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), `${expectedArgument} must be a positive integer`, (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n  }\n\n  const receivedName = received.getMockName();\n  const {\n    calls,\n    results\n  } = received.mock;\n  const length = results.length;\n  const iNth = nth - 1;\n  const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n  const message = pass ? () => {\n    // Display preceding and following results,\n    // in case assertions fails because index is off by one.\n    const indexedResults = [];\n\n    if (iNth - 1 >= 0) {\n      indexedResults.push([iNth - 1, results[iNth - 1]]);\n    }\n\n    indexedResults.push([iNth, results[iNth]]);\n\n    if (iNth + 1 < length) {\n      indexedResults.push([iNth + 1, results[iNth + 1]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `n: ${nth}\\n` + `Expected: not ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iNth)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    // Display preceding and following results:\n    // * nearest result that is equal to expected value\n    // * otherwise, adjacent result\n    // in case assertions fails because of index, especially off by one.\n    const indexedResults = [];\n\n    if (iNth < length) {\n      if (iNth - 1 >= 0) {\n        let i = iNth - 1; // Is there a preceding result that is equal to expected value?\n\n        while (i >= 0 && !isEqualReturn(expected, results[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iNth - 1; // otherwise, adjacent result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n\n      indexedResults.push([iNth, results[iNth]]);\n\n      if (iNth + 1 < length) {\n        let i = iNth + 1; // Is there a following result that is equal to expected value?\n\n        while (i < length && !isEqualReturn(expected, results[i])) {\n          i += 1;\n        }\n\n        if (i >= length) {\n          i = iNth + 1; // otherwise, adjacent result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n    } else if (length > 0) {\n      // The number of received calls is fewer than the expected number.\n      let i = length - 1; // Is there a result that is equal to expected value?\n\n      while (i >= 0 && !isEqualReturn(expected, results[i])) {\n        i -= 1;\n      }\n\n      if (i < 0) {\n        i = length - 1; // otherwise, last result\n      }\n\n      indexedResults.push([i, results[i]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + `n: ${nth}\\n` + `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iNth) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst spyMatchers = {\n  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n  toBeCalled: createToBeCalledMatcher('toBeCalled'),\n  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),\n  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n  toHaveBeenLastCalledWith: createLastCalledWithMatcher('toHaveBeenLastCalledWith'),\n  toHaveBeenNthCalledWith: createNthCalledWithMatcher('toHaveBeenNthCalledWith'),\n  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),\n  toHaveReturned: createToReturnMatcher('toHaveReturned'),\n  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n  toReturn: createToReturnMatcher('toReturn'),\n  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n  toReturnWith: createToReturnWithMatcher('toReturnWith')\n};\n\nconst isMock = received => received != null && received._isMockFunction === true;\n\nconst isSpy = received => received != null && received.calls != null && typeof received.calls.all === 'function' && typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be a mock or spy function`, (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nconst ensureMock = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be a mock function`, (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nvar _default = spyMatchers;\nexports.default = _default;","map":{"version":3,"sources":["D:/IDEA workspace/ZUA/community-manage-react/node_modules/expect/build/spyMatchers.js"],"names":["Object","defineProperty","exports","value","default","_jestGetType","_interopRequireDefault","require","_jestMatcherUtils","_jasmineUtils","_utils","obj","__esModule","isExpand","expand","PRINT_LIMIT","NO_ARGUMENTS","printExpectedArgs","expected","length","map","arg","printExpected","join","printReceivedArgs","received","i","Array","isArray","isEqualValue","printCommon","printReceived","val","DIM_COLOR","stringify","equals","iterableEquality","isEqualCall","isEqualReturn","result","type","countReturns","results","reduce","n","printNumberOfReturns","countCalls","getRightAlignedPrinter","label","index","indexOf","suffix","slice","string","isExpectedCall","repeat","Math","max","printReceivedCallsNegative","indexedCalls","isOnlyCall","iExpectedCall","printAligned","printed","args","String","printExpectedReceivedCallsPositive","expectedLine","undefined","isLineDiffableCall","lines","EXPECTED_COLOR","RECEIVED_COLOR","push","isLineDiffableArg","difference","diff","includes","split","aligned","replace","printDiffCall","indentation","line","some","expectedType","receivedType","isPrimitive","Error","asymmetricMatch","printResult","printReceivedResults","indexedResults","trim","createToBeCalledMatcher","matcherName","expectedArgument","options","isNot","promise","ensureNoExpected","ensureMockOrSpy","receivedIsSpy","isSpy","receivedName","getMockName","count","calls","mock","all","x","pass","message","matcherHint","createToReturnMatcher","ensureMock","createToBeCalledTimesMatcher","ensureExpectedIsNonNegativeInteger","createToReturnTimesMatcher","createToBeCalledWithMatcher","call","createToReturnWithMatcher","createLastCalledWithMatcher","iLast","createLastReturnedMatcher","createNthCalledWithMatcher","nth","expectedColor","secondArgument","Number","isSafeInteger","matcherErrorMessage","printWithType","iNth","createNthReturnedWithMatcher","spyMatchers","lastCalledWith","lastReturnedWith","nthCalledWith","nthReturnedWith","toBeCalled","toBeCalledTimes","toBeCalledWith","toHaveBeenCalled","toHaveBeenCalledTimes","toHaveBeenCalledWith","toHaveBeenLastCalledWith","toHaveBeenNthCalledWith","toHaveLastReturnedWith","toHaveNthReturnedWith","toHaveReturned","toHaveReturnedTimes","toHaveReturnedWith","toReturn","toReturnTimes","toReturnWith","isMock","_isMockFunction","_default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// The optional property of matcher context is true if undefined.\nconst isExpand = expand => expand !== false;\n\nconst PRINT_LIMIT = 3;\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = expected =>\n  expected.length === 0\n    ? NO_ARGUMENTS\n    : expected.map(arg => (0, _jestMatcherUtils.printExpected)(arg)).join(', ');\n\nconst printReceivedArgs = (received, expected) =>\n  received.length === 0\n    ? NO_ARGUMENTS\n    : received\n        .map((arg, i) =>\n          Array.isArray(expected) &&\n          i < expected.length &&\n          isEqualValue(expected[i], arg)\n            ? printCommon(arg)\n            : (0, _jestMatcherUtils.printReceived)(arg)\n        )\n        .join(', ');\n\nconst printCommon = val =>\n  (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));\n\nconst isEqualValue = (expected, received) =>\n  (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);\n\nconst isEqualCall = (expected, received) => isEqualValue(expected, received);\n\nconst isEqualReturn = (expected, result) =>\n  result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = results =>\n  results.reduce((n, result) => (result.type === 'return' ? n + 1 : n), 0);\n\nconst printNumberOfReturns = (countReturns, countCalls) =>\n  `\\nNumber of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns)}` +\n  (countCalls !== countReturns\n    ? `\\nNumber of calls:   ${(0, _jestMatcherUtils.printReceived)(countCalls)}`\n    : '');\n\n// Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\nconst getRightAlignedPrinter = label => {\n  // Assume that the label contains a colon.\n  const index = label.indexOf(':');\n  const suffix = label.slice(index);\n  return (string, isExpectedCall) =>\n    (isExpectedCall\n      ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length))\n      : ' '.repeat(Math.max(index - string.length))) +\n    string +\n    suffix;\n};\n\nconst printReceivedCallsNegative = (\n  expected,\n  indexedCalls,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  const label = 'Received:     ';\n\n  if (isOnlyCall) {\n    return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    'Received\\n' +\n    indexedCalls.reduce(\n      (printed, [i, args]) =>\n        printed +\n        printAligned(String(i + 1), i === iExpectedCall) +\n        printReceivedArgs(args, expected) +\n        '\\n',\n      ''\n    )\n  );\n};\n\nconst printExpectedReceivedCallsPositive = (\n  expected,\n  indexedCalls,\n  expand,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  const expectedLine = `Expected: ${printExpectedArgs(expected)}\\n`;\n\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  const label = 'Received: ';\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    const received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      const lines = [\n        (0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'),\n        (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'),\n        ''\n      ];\n      const length = Math.max(expected.length, received.length);\n\n      for (let i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(`  ${printCommon(received[i])},`);\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            const difference = (0, _jestMatcherUtils.diff)(\n              expected[i],\n              received[i],\n              {\n                expand\n              }\n            );\n\n            if (\n              typeof difference === 'string' &&\n              difference.includes('- Expected') &&\n              difference.includes('+ Received')\n            ) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(difference.split('\\n').slice(3).join('\\n') + ',');\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push(\n            (0, _jestMatcherUtils.EXPECTED_COLOR)(\n              '- ' + (0, _jestMatcherUtils.stringify)(expected[i])\n            ) + ','\n          );\n        }\n\n        if (i < received.length) {\n          lines.push(\n            (0, _jestMatcherUtils.RECEIVED_COLOR)(\n              '+ ' + (0, _jestMatcherUtils.stringify)(received[i])\n            ) + ','\n          );\n        }\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n\n    return expectedLine + label + printReceivedArgs(received, expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    expectedLine +\n    'Received\\n' +\n    indexedCalls.reduce((printed, [i, received]) => {\n      const aligned = printAligned(String(i + 1), i === iExpectedCall);\n      return (\n        printed +\n        ((i === iExpectedCall || iExpectedCall === undefined) &&\n        isLineDiffableCall(expected, received)\n          ? aligned.replace(': ', '\\n') +\n            printDiffCall(expected, received, expand)\n          : aligned + printReceivedArgs(received, expected)) +\n        '\\n'\n      );\n    }, '')\n  );\n};\n\nconst indentation = 'Received'.replace(/\\w/g, ' ');\n\nconst printDiffCall = (expected, received, expand) =>\n  received\n    .map((arg, i) => {\n      if (i < expected.length) {\n        if (isEqualValue(expected[i], arg)) {\n          return indentation + '  ' + printCommon(arg) + ',';\n        }\n\n        if (isLineDiffableArg(expected[i], arg)) {\n          const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {\n            expand\n          });\n\n          if (\n            typeof difference === 'string' &&\n            difference.includes('- Expected') &&\n            difference.includes('+ Received')\n          ) {\n            // Display diff with indentation.\n            // Omit annotation in case multiple args have diff.\n            return (\n              difference\n                .split('\\n')\n                .slice(3)\n                .map(line => indentation + line)\n                .join('\\n') + ','\n            );\n          }\n        }\n      } // Display + only if received arg has no corresponding expected arg.\n\n      return (\n        indentation +\n        (i < expected.length\n          ? '  ' + (0, _jestMatcherUtils.printReceived)(arg)\n          : (0, _jestMatcherUtils.RECEIVED_COLOR)(\n              '+ ' + (0, _jestMatcherUtils.stringify)(arg)\n            )) +\n        ','\n      );\n    })\n    .join('\\n');\n\nconst isLineDiffableCall = (expected, received) =>\n  expected.some(\n    (arg, i) => i < received.length && isLineDiffableArg(arg, received[i])\n  ); // Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\n\nconst isLineDiffableArg = (expected, received) => {\n  const expectedType = (0, _jestGetType.default)(expected);\n  const receivedType = (0, _jestGetType.default)(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (_jestGetType.default.isPrimitive(expected)) {\n    return false;\n  }\n\n  if (\n    expectedType === 'date' ||\n    expectedType === 'function' ||\n    expectedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (\n    expectedType === 'object' &&\n    typeof expected.asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof received.asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nconst printResult = (result, expected) =>\n  result.type === 'throw'\n    ? 'function call threw an error'\n    : result.type === 'incomplete'\n    ? 'function call has not returned yet'\n    : isEqualValue(expected, result.value)\n    ? printCommon(result.value)\n    : (0, _jestMatcherUtils.printReceived)(result.value);\n\n// Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\nconst printReceivedResults = (\n  label,\n  expected,\n  indexedResults,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return label + printResult(indexedResults[0][1], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    label.replace(':', '').trim() +\n    '\\n' +\n    indexedResults.reduce(\n      (printed, [i, result]) =>\n        printed +\n        printAligned(String(i + 1), i === iExpectedCall) +\n        printResult(result, expected) +\n        '\\n',\n      ''\n    )\n  );\n};\n\nconst createToBeCalledMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = '';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const pass = count > 0;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(\n            0\n          )}\\n` +\n          `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}\\n\\n` +\n          calls\n            .reduce((lines, args, i) => {\n              if (lines.length < PRINT_LIMIT) {\n                lines.push(`${i + 1}: ${printReceivedArgs(args)}`);\n              }\n\n              return lines;\n            }, [])\n            .join('\\n')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: >= ${(0, _jestMatcherUtils.printExpected)(\n            1\n          )}\\n` +\n          `Received number of calls:    ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}`;\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = '';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    const count = received.mock.results.reduce(\n      (n, result) => (result.type === 'return' ? n + 1 : n),\n      0\n    );\n    const pass = count > 0;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(\n            0\n          )}\\n` +\n          `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}\\n\\n` +\n          received.mock.results\n            .reduce((lines, result, i) => {\n              if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n                lines.push(\n                  `${i + 1}: ${(0, _jestMatcherUtils.printReceived)(\n                    result.value\n                  )}`\n                );\n              }\n\n              return lines;\n            }, [])\n            .join('\\n') +\n          (received.mock.calls.length !== count\n            ? `\\n\\nReceived number of calls:   ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: >= ${(0,\n          _jestMatcherUtils.printExpected)(1)}\\n` +\n          `Received number of returns:    ${(0,\n          _jestMatcherUtils.printReceived)(count)}` +\n          (received.mock.calls.length !== count\n            ? `\\nReceived number of calls:      ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '');\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToBeCalledTimesMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(\n      expected,\n      matcherName,\n      options\n    );\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n    const pass = count === expected;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          `\\n\\n` +\n          `Expected number of calls: not ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}`\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}\\n` +\n          `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}`;\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnTimesMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(\n      expected,\n      matcherName,\n      options\n    );\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    const count = received.mock.results.reduce(\n      (n, result) => (result.type === 'return' ? n + 1 : n),\n      0\n    );\n    const pass = count === expected;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          `\\n\\n` +\n          `Expected number of returns: not ${(0,\n          _jestMatcherUtils.printExpected)(expected)}` +\n          (received.mock.calls.length !== count\n            ? `\\n\\nReceived number of calls:       ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}\\n` +\n          `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}` +\n          (received.mock.calls.length !== count\n            ? `\\nReceived number of calls:   ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '');\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToBeCalledWithMatcher = matcherName =>\n  function (received, ...expected) {\n    const expectedArgument = '...expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const pass = calls.some(call => isEqualCall(expected, call));\n    const message = pass\n      ? () => {\n          // Some examples of calls that are equal to expected value.\n          const indexedCalls = [];\n          let i = 0;\n\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            if (isEqualCall(expected, calls[i])) {\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          // Some examples of calls that are not equal to expected value.\n          const indexedCalls = [];\n          let i = 0;\n\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            indexedCalls.push([i, calls[i]]);\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnWithMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const pass = results.some(result => isEqualReturn(expected, result));\n    const message = pass\n      ? () => {\n          // Some examples of results that are equal to expected value.\n          const indexedResults = [];\n          let i = 0;\n\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            if (isEqualReturn(expected, results[i])) {\n              indexedResults.push([i, results[i]]);\n            }\n\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Some examples of results that are not equal to expected value.\n          const indexedResults = [];\n          let i = 0;\n\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            indexedResults.push([i, results[i]]);\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createLastCalledWithMatcher = matcherName =>\n  function (received, ...expected) {\n    const expectedArgument = '...expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const iLast = calls.length - 1;\n    const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n    const message = pass\n      ? () => {\n          const indexedCalls = [];\n\n          if (iLast > 0) {\n            // Display preceding call as context.\n            indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n          }\n\n          indexedCalls.push([iLast, calls[iLast]]);\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iLast\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          const indexedCalls = [];\n\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1; // Is there a preceding call that is equal to expected args?\n\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            indexedCalls.push([iLast, calls[iLast]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iLast\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createLastReturnedMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const iLast = results.length - 1;\n    const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n    const message = pass\n      ? () => {\n          const indexedResults = [];\n\n          if (iLast > 0) {\n            // Display preceding result as context.\n            indexedResults.push([iLast - 1, results[iLast - 1]]);\n          }\n\n          indexedResults.push([iLast, results[iLast]]);\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iLast\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          const indexedResults = [];\n\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1; // Is there a preceding result that is equal to expected value?\n\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n\n            indexedResults.push([iLast, results[iLast]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iLast\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createNthCalledWithMatcher = matcherName =>\n  function (received, nth, ...expected) {\n    const expectedArgument = 'n';\n    const options = {\n      expectedColor: arg => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: '...expected'\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            expectedArgument,\n            options\n          ),\n          `${expectedArgument} must be a positive integer`,\n          (0, _jestMatcherUtils.printWithType)(\n            expectedArgument,\n            nth,\n            _jestMatcherUtils.stringify\n          )\n        )\n      );\n    }\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const length = calls.length;\n    const iNth = nth - 1;\n    const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n    const message = pass\n      ? () => {\n          // Display preceding and following calls,\n          // in case assertions fails because index is off by one.\n          const indexedCalls = [];\n\n          if (iNth - 1 >= 0) {\n            indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n          }\n\n          indexedCalls.push([iNth, calls[iNth]]);\n\n          if (iNth + 1 < length) {\n            indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iNth\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          // Display preceding and following calls:\n          // * nearest call that is equal to expected args\n          // * otherwise, adjacent call\n          // in case assertions fails because of index, especially off by one.\n          const indexedCalls = [];\n\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1; // Is there a preceding call that is equal to expected args?\n\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            indexedCalls.push([iNth, calls[iNth]]);\n\n            if (iNth + 1 < length) {\n              let i = iNth + 1; // Is there a following call that is equal to expected args?\n\n              while (i < length && !isEqualCall(expected, calls[i])) {\n                i += 1;\n              }\n\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1; // Is there a call that is equal to expected args?\n\n            while (i >= 0 && !isEqualCall(expected, calls[i])) {\n              i -= 1;\n            }\n\n            if (i < 0) {\n              i = length - 1; // otherwise, last call\n            }\n\n            indexedCalls.push([i, calls[i]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iNth\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createNthReturnedWithMatcher = matcherName =>\n  function (received, nth, expected) {\n    const expectedArgument = 'n';\n    const options = {\n      expectedColor: arg => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: 'expected'\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            expectedArgument,\n            options\n          ),\n          `${expectedArgument} must be a positive integer`,\n          (0, _jestMatcherUtils.printWithType)(\n            expectedArgument,\n            nth,\n            _jestMatcherUtils.stringify\n          )\n        )\n      );\n    }\n\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const length = results.length;\n    const iNth = nth - 1;\n    const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n    const message = pass\n      ? () => {\n          // Display preceding and following results,\n          // in case assertions fails because index is off by one.\n          const indexedResults = [];\n\n          if (iNth - 1 >= 0) {\n            indexedResults.push([iNth - 1, results[iNth - 1]]);\n          }\n\n          indexedResults.push([iNth, results[iNth]]);\n\n          if (iNth + 1 < length) {\n            indexedResults.push([iNth + 1, results[iNth + 1]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iNth\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Display preceding and following results:\n          // * nearest result that is equal to expected value\n          // * otherwise, adjacent result\n          // in case assertions fails because of index, especially off by one.\n          const indexedResults = [];\n\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1; // Is there a preceding result that is equal to expected value?\n\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n\n            indexedResults.push([iNth, results[iNth]]);\n\n            if (iNth + 1 < length) {\n              let i = iNth + 1; // Is there a following result that is equal to expected value?\n\n              while (i < length && !isEqualReturn(expected, results[i])) {\n                i += 1;\n              }\n\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1; // Is there a result that is equal to expected value?\n\n            while (i >= 0 && !isEqualReturn(expected, results[i])) {\n              i -= 1;\n            }\n\n            if (i < 0) {\n              i = length - 1; // otherwise, last result\n            }\n\n            indexedResults.push([i, results[i]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iNth\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst spyMatchers = {\n  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n  toBeCalled: createToBeCalledMatcher('toBeCalled'),\n  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),\n  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n  toHaveBeenLastCalledWith: createLastCalledWithMatcher(\n    'toHaveBeenLastCalledWith'\n  ),\n  toHaveBeenNthCalledWith: createNthCalledWithMatcher(\n    'toHaveBeenNthCalledWith'\n  ),\n  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),\n  toHaveReturned: createToReturnMatcher('toHaveReturned'),\n  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n  toReturn: createToReturnMatcher('toReturn'),\n  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n  toReturnWith: createToReturnWithMatcher('toReturnWith')\n};\n\nconst isMock = received =>\n  received != null && received._isMockFunction === true;\n\nconst isSpy = received =>\n  received != null &&\n  received.calls != null &&\n  typeof received.calls.all === 'function' &&\n  typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          expectedArgument,\n          options\n        ),\n        `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n          'received'\n        )} value must be a mock or spy function`,\n        (0, _jestMatcherUtils.printWithType)(\n          'Received',\n          received,\n          _jestMatcherUtils.printReceived\n        )\n      )\n    );\n  }\n};\n\nconst ensureMock = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received)) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          expectedArgument,\n          options\n        ),\n        `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n          'received'\n        )} value must be a mock function`,\n        (0, _jestMatcherUtils.printWithType)(\n          'Received',\n          received,\n          _jestMatcherUtils.printReceived\n        )\n      )\n    );\n  }\n};\n\nvar _default = spyMatchers;\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}